<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.7.4 at 2017-08-30 
 | Rendered using Apache Maven Fluido Skin 1.6
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20170830" />
    <meta http-equiv="Content-Language" content="en" />
    <title>Alternet Parsing &#x2013; Alternet Parsing</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.6.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
      <script type="text/javascript" src="./js/apache-maven-fluido-1.6.min.js"></script>
      </head>
    <body class="topBarEnabled">
      <div id="topbar" class="navbar navbar-fixed-top ">
      <div class="navbar-inner">
            <div class="container"><div class="nav-collapse">
            <ul class="nav">
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Main <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../" title="Home">Home</a></li>
            <li><a href="https://github.com/alternet/alternet-libs" title="GitHub project">GitHub project</a></li>
            <li><a href="http://semantic-mismatch.blogspot.fr/" title="Blog">Blog</a></li>
            <li><a href="../release-notes.html" title="Release notes">Release notes</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Download <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../download.html" title="Download">Download</a></li>
            <li><a href="../license.html" title="License">License</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../parsing/index.html" title="Alternet Parsing">Alternet Parsing</a></li>
            <li><a href="../scanner/index.html" title="Alternet Scanner">Alternet Scanner</a></li>
            <li><a href="../security/index.html" title="Alternet Security">Alternet Security</a></li>
            <li><a href="../tools/index.html" title="Alternet Tools">Alternet Tools</a></li>
            <li><a href="../tools-generator/index.html" title="Alternet Tools - Generator">Alternet Tools - Generator</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Maven reports <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li class="dropdown-submenu">
<a href="project-info.html" title="Project Information">Project Information</a>
              <ul class="dropdown-menu">
                  <li><a href="project-summary.html" title="Summary">Summary</a></li>
                  <li><a href="license.html" title="Licenses">Licenses</a></li>
                  <li><a href="team-list.html" title="Team">Team</a></li>
                  <li><a href="source-repository.html" title="Source Code Management">Source Code Management</a></li>
                  <li><a href="issue-tracking.html" title="Issue Management">Issue Management</a></li>
                  <li><a href="dependencies.html" title="Dependencies">Dependencies</a></li>
                  <li><a href="dependency-convergence.html" title="Dependency Convergence">Dependency Convergence</a></li>
                  <li><a href="plugins.html" title="Plugins">Plugins</a></li>
              </ul>
            </li>
            <li class="dropdown-submenu">
<a href="project-reports.html" title="Project Reports">Project Reports</a>
              <ul class="dropdown-menu">
                  <li><a href="xref/index.html" title="Source Xref">Source Xref</a></li>
                  <li><a href="xref-test/index.html" title="Test Source Xref">Test Source Xref</a></li>
                  <li><a href="surefire-report.html" title="Surefire Report">Surefire Report</a></li>
                  <li><a href="pmd.html" title="PMD">PMD</a></li>
                  <li><a href="checkstyle.html" title="Checkstyle">Checkstyle</a></li>
              </ul>
            </li>
        </ul>
      </li>
              </ul>
                    <ul class="nav pull-right">
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">External Links <b class="caret"></b></a>
                <ul class="dropdown-menu">
    <li><a href="https://github.com/alternet/alternet.ml" title="GitHub project">GitHub project</a></li>
    <li><a href="../demo.html" title="Other Demos">Other Demos</a></li>
                </ul>
              </li>
            </ul>
            </div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>Alternet Parsing</h2>
</div>
</div>
        <div class="pull-right"></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2017-08-30<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.0<span class="divider">|</span></li>
        <li class=""><a href="../.." title="Alternet">Alternet</a><span class="divider">»</span></li>
      <li class=""><a href="../index.html" title="Alternet Libs">Alternet Libs</a><span class="divider">»</span></li>
      <li class=""><a href="index.html" title="Alternet Parsing">Alternet Parsing</a><span class="divider">»</span></li>
    <li class="active ">Alternet Parsing</li>
        </ul>
      </div>
        <div id="bodyColumn" >
<h1>Alternet Parsing</h1>
<p>Alternet Parsing is a nice Parsing Expression Grammar framework that includes an Abstract Syntax Tree builder.</p>

<ol style="list-style-type: decimal">
  
<li><a href="#overview">Overview</a></li>
  
<li><a href="#grammar-tutorial">Grammar tutorial</a></li>
  
<li><a href="#parsing-tutorial">Parsing tutorial</a></li>
</ol>
<p><a name="overview"></a></p>
<div class="section">
<h2><a name="Overview"></a>Overview</h2>
<div class="section">
<h3><a name="Maven_import"></a>Maven import</h3>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;dependency&gt;
    &lt;groupId&gt;ml.alternet&lt;/groupId&gt;
    &lt;artifactId&gt;alternet-parsing&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;
</pre></div></div></div>
<div class="section">
<h3><a name="JavaDoc_API_documentation"></a>JavaDoc API documentation</h3>

<ul>
  
<li><a href="apidocs/index.html">Alternet Parsing</a></li>
</ul>
<p>Other Alternet APIs :</p>

<ul>
  
<li><a href="../apidocs/index.html">Alternet Libs</a></li>
</ul></div>
<div class="section">
<h3><a name="Features"></a>Features</h3>
<p>Some tools are already existing for designing grammars.</p>
<p>Alternet Parsing takes the bet that you don&#x2019;t want to learn a new DSL (such as with the well-known ANTLR tool), and therefore allow you to write your grammar in pure Java code.</p>
<p>A grammar in Alternet Parsing is just an interface, which allow to avoid pollute the code with Java modifiers (namely &#x201c;<tt>public static final</tt>&#x201d;) ; the other benefits with interfaces is that you can have multiple inheritence, which allow you to extend by composition new grammars. Overriding a rule is as simple as you expect.</p>
<p>A grammar in Alternet Parsing (almost) follows the way rules are written in grammar-formal languages, you are not lost by the order rules are written.</p>
<p>There are 3 main citizens in Alternet Parsing : the <a href="apidocs/ml/alternet/parser/Grammar.html"><tt>Grammar</tt></a>, the <a href="apidocs/ml/alternet/parser/Grammar.Rule.html"><tt>Rule</tt></a>, and the <a href="apidocs/ml/alternet/parser/Grammar.Token.html"><tt>Token</tt></a> (a token is also a rule).</p>
<p>Alternet Parsing comes with out-of-the-box convenient features such as :</p>

<ul>
  
<li>no boilerplate code</li>
  
<li>easy parsing of enum values and ranges of characters (combination by union and exclusion)</li>
  
<li>rules written in Java are following the natural writing of (most) formal grammar languages</li>
  
<li>easy extension, combining facilities, and overriding</li>
  
<li>can scan strings or streams of characters</li>
  
<li>whitespace handling policy set by annotation on a grammar and overridable on any token</li>
  
<li>clean separation of grammar and parser</li>
  
<li>nice token to custom object mappings facilities</li>
  
<li>out-of-the-box abstract syntax tree builder</li>
  
<li>etc&#x2026;</li>
</ul>
<p><a name="grammar-tutorial"></a></p></div></div>
<div class="section">
<h2><a name="Grammar_tutorial"></a>Grammar tutorial</h2>
<p>In this tutorial, we are writing a grammar that allow to parse a simple mathematical expression like this :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
sin(x)*(1+var_12)
</pre></div></div>
<p>The formal grammar definition looks like this, and we intend to write it in pure Java as close as possible to the original :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
[01] LBRACKET       ::= '('
[02] RBRACKET       ::= ')'
[03] FUNCTION       ::= 'sin' | 'cos' | 'exp' | 'ln' | 'sqrt'
[04] ADDITIVE       ::= '+' | '-'
[05] MULTIPLICATIVE ::= '*' | '/'
[06] UNDERSCORE     ::= '_'
[07] DIGIT          ::= [0-9]
[08] NUMBER         ::= DIGIT+
[09] UPPERCASE      ::= [A-Z]
[10] LOWERCASE      ::= [a-z]
[11] VARIABLE       ::= (LOWERCASE | UPPERCASE) (LOWERCASE | UPPERCASE | DIGIT | UNDERSCORE)*

[12] Expression     ::= Sum
[13] Value          ::= NUMBER | VARIABLE
[14] Argument       ::= FUNCTION Argument | Value | '(' Expression ')'
[15] Factor         ::= Argument ('^' SignedFactor)?
[16] Product        ::= Factor (MULTIPLICATIVE SignedFactor)*
[17] SignedTerm     ::= ADDITIVE? Product
[18] SignedFactor   ::= ADDITIVE? Factor
[19] Sum            ::= SignedTerm (ADDITIVE Product)*
</pre></div></div>
<div class="section">
<h3><a name="The_grammar_skeleton"></a>The grammar skeleton</h3>
<p>Let&#x2019;s start with the skeleton of our class. As mentioned earlier, a grammar in Alternet Parsing MUST BE an <tt>interface</tt> ; and it has to extend the <a href="apidocs/ml/alternet/parser/Grammar.html"><tt>Grammar</tt></a> interface :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">package org.example.grammar;

import static ml.alternet.parser.Grammar.*;

public interface Calc extends Grammar {

    // Rules and Tokens will be defined here

    Calc $ = $(); // it MUST BE the last field of the grammar

}
</pre></div></div>
<p>The static import contains all the material useful for building your grammar. If you use an IDE you will have it available on autocompletion.</p>
<p>As a requirement, the last field of your grammar (actually the only one so far, <tt>$</tt>) must hold an instance of your grammar (generated by <tt>$()</tt>), which will allow to parse the input text (we will talk later about that), and in some rare cases referring fields through the grammar instance.</p>

<div class="alert alert-warning" role="alert">

<ul>

<li>The Grammar field will serve to parse the input</li>

<li>All the Rules and Tokens MUST BE declared BEFORE the Grammar field.</li>
</ul>
</div></div>
<div class="section">
<h3><a name="Tokens"></a>Tokens</h3>
<p>First, we just need to enumerate the tokens that are part of the grammar. A <a href="apidocs/ml/alternet/parser/Grammar.Token.html"><tt>Token</tt></a>  is just a character, or a sequence of characters, that are terminal values of the grammar, and to which we give a name. Therefore, if you look at the mathematical expression, we can identify the left bracket as being the character &#x2018;(&#x2019; ; in our grammar, we simply add a new field for the left bracket, and a second one for the right bracket :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //    LBRACKET   ::= '('
    Token LBRACKET = is( '(' );
    //    RBRACKET   ::= ')'
    Token RBRACKET = is( ')' );
</pre></div></div>
<p>You may read it as you write it : the token <tt>LBRACKET</tt> is the character &#x2018;<tt>(</tt>&#x2019;.</p>
<p>Since you are defining those fields in a Java <tt>interface</tt>, no need to specify <tt>public static final</tt> on them.</p>

<div class="alert alert-info" role="alert">

<p>Supplementary Unicode characters (whose code points are greater than U+FFFF) can also be defined as tokens :</p>

<div class="source">
<div class="source">
<pre class="prettyprint linenums">
   Token UNICODE_CHAR_CODE = is(0x1F60E);
   Token UNICODE_CHAR = is(&quot;&#x1f60e;&quot;.codePointAt(0));

   Token UNICODE_STRING = isOneOf(&quot;&#x1f60e;&#x1f44d;&#x1f340;&quot;);
</pre></div></div>
</div>
<p>Similarly, we could define a token for the <tt>sin</tt> function that appears in the mathematical expression :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
    Token SIN_FUNCTION = is(&quot;sin&quot;);
</pre></div></div>
<div class="section">
<h4><a name="Enum_tokens"></a>Enum tokens</h4>
<p>We could enumerate the other functions that our parser have to support, but since we are writing our grammar in Java, we can do better. Instead, we are designing an enum class, and create a token based on its values :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // FUNCTION ::= 'sin' | 'cos' | 'exp' | 'ln' | 'sqrt'
    enum Function {
        sin, cos, exp, ln, sqrt;
    }
    Token FUNCTION = is(Function.class);
</pre></div></div>
<p>Again, you may read it as you write it : the token <tt>FUNCTION</tt> is given by the enum <tt>Function.class</tt>.</p>
<p>Sometimes, a token can&#x2019;t be written as an enum value, because Java names have naming constraints. This is the case in our grammar, we want to write an enum class for &#x201c;+&#x201d; and &#x201c;-&#x201d; but they are invalid Java names :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // ADDITIVE ::= '+' | '-'
    enum Additive {
        +, -; // &#x26d4; you can't write that in Java
    }
    Token ADDITIVE = is(Additive.class);
</pre></div></div>
<p>We have a tool for getting rid of that limitations. First, add the following import :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">import static ml.alternet.util.EnumUtil.replace;
</pre></div></div>
<p>&#x2026;and use it in the constructor like this in order to replace the token value by the one supplied :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // ADDITIVE ::= '+' | '-'
    enum Additive {
        PLUS(&quot;+&quot;), MINUS(&quot;-&quot;);
        Additive(String str) {
            replace(Additive.class, this, s -&gt; str);
        }
    }
    Token ADDITIVE = is(Additive.class);
</pre></div></div>
<p>The <tt>PLUS</tt> value will be replaced by the <tt>+</tt> value, and the <tt>MINUS</tt> value will be replaced by the <tt>-</tt> value. The idea is to have in enum types tokens that are exactly those expected in the input text. If the input to parse contains &#x201c;<tt>+</tt>&#x201d; the token value get will be <tt>Additive.PLUS</tt>.</p>
<p>Repeat for the multiplicative token :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // MULTIPLICATIVE ::= '*' | '/'
    enum Multiplicative {
        MULT(&quot;*&quot;), DIV(&quot;/&quot;);
        Multiplicative(String str) {
            replace(Multiplicative.class, this, s -&gt; str);
        }
    }
    Token MULTIPLICATIVE = is(Multiplicative.class);
</pre></div></div>
<p>Sometimes, the replacement is generic. Let&#x2019;s consider the XPath grammar : if you look at the <a class="externalLink" href="https://www.w3.org/TR/xpath/#axes">XPath specification</a>, you will find 13 axis that contain a &#x201c;-&#x201d; in their names, which is an invalid character in Java names. Instead, we will write the values with &#x201c;_&#x201d; and replace them in the constructor like this :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // [6] AxisName   ::=   'ancestor' | 'ancestor-or-self' | 'attribute'
    //                    | 'child' | 'descendant' | 'descendant-or-self'
    //                    | 'following' | 'following-sibling' | 'namespace'
    //                    | 'parent' | 'preceding' | 'preceding-sibling' | 'self'
    public enum Axis {
            ancestor, ancestor_or_self, attribute,
            child, descendant, descendant_or_self,
            following, following_sibling, namespace,
            parent, preceding, preceding_sibling, self;
        Axis() {
            // replace the &quot;_&quot; in the name by a &quot;-&quot;
            replace(Axis.class, this, s -&gt; s.replace('_', '-'));
        }
    }
    Token AxisName = is(Axis.class);
</pre></div></div>
<p>When parsing, the longest value if available will be read from the input. That is to say if the input contains &#x201c;<tt>ancestor-or-self</tt>&#x201d; the token value get will be <tt>Axis.ancestor_or_self</tt> and not jut <tt>Axis.ancestor</tt>. It means that the order of the enum values doesn&#x2019;t matter in the enum class. Internally, the tokenizer is smart enough to group commons characters together to avoid testing the same sequence several times.</p></div>
<div class="section">
<h4><a name="Fragment_tokens_and_composed_tokens"></a>Fragment tokens and composed tokens</h4>
<p>Let&#x2019;s go back in our grammar.</p>
<p>The production of variable names (<tt>var_12</tt> in our example) is made of &#x201c;_&#x201d;, digits, and lowercase or uppercase characters. We can define the expected tokens like this :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //              UNDERSCORE  ::= '_';
    @Fragment Token UNDERSCORE = is('_');

    //              UPPERCASE     ::= [A-Z]
    @Fragment Token UPPERCASE = range('A', 'Z');

    //              LOWERCASE     ::= [a-z]
    @Fragment Token LOWERCASE = range('a', 'z');

    //              DIGIT     ::= [0-9]
    @Fragment Token DIGIT = range('0', '9')
            .asNumber();

    //    VARIABLE ::= (LOWERCASE  |  UPPERCASE) (LOWERCASE | UPPERCASE | DIGIT | UNDERSCORE)*
    Token VARIABLE = ( (LOWERCASE).or(UPPERCASE) ).seq(
            ( (LOWERCASE).or(UPPERCASE).or(DIGIT).or(UNDERSCORE) ).zeroOrMore() )
            .asToken();
</pre></div></div>

<ul>
  
<li>The production of <tt>Token DIGIT</tt> ends with <tt>.asNumber();</tt>, that is a convenient method to get number values instead of raw strings during parsing.</li>
  
<li>The production of <tt>Token VARIABLE</tt> ends with <tt>.asToken();</tt>. In fact, we have written our first <tt>Rule</tt> but we want to turn the entire rule in a simple token. We will examine rules in detail in the next section.</li>
  
<li>In fact, the <tt>Token VARIABLE</tt> is made of smaller tokens, that are marked as <tt>@Fragment</tt>.</li>
</ul>
<p><a href="apidocs/ml/alternet/parser/Grammar.Fragment.html"><tt>@Fragment</tt></a> ? A token is not necessary the smallest component of a grammar, but rather the smallest <i>useful</i> component of a grammar. In fact, we have convenient <tt>@Fragment</tt>s tokens that are defined here because they may be used elsewhere. But the real useful part is to have a <tt>VARIABLE</tt> produced by the parser, we don&#x2019;t care that that variable name is made of a mix of uppercase, lowercase, digits, and underscore characters (our grammar ensure that it will be the case), we just want a variable name. If we omit the <tt>@Fragment</tt> annotation, each individual tokens will be produced by the parser and may mask the production of a <tt>VARIABLE</tt> token. However, when entering a token composed of other tokens, the components will be considered as fragments. Setting a <tt>@Fragment</tt> annotation indicates that the target token is not eligible for selection.</p>
<p>We can reuse the previously fragments defined elsewhere by using <tt>.asToken()</tt> if we want a string token, or <tt>.asNumber()</tt> if we want a number. A token annotated as fragment will be discarded, except if it is used in a rule exposed itself as a token with <tt>.asToken()</tt> or <tt>.asNumber()</tt> : such rule will aggregate the tokens. Be aware that for a rule made of non-fragment tokens, the matched characters will be reported twice !</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // NUMBER  ::= DIGIT+
    Token NUMBER = DIGIT.oneOrMore()
            .asNumber();
</pre></div></div>
<p>All non-fragments tokens can be get in the so-called &#x201c;tokenizer rule&#x201d; by the method <a href="apidocs/ml/alternet/parser/Grammar.html#tokenizer--"><tt>Calc.$.tokenizer()</tt></a> (more on this later).</p>
<p>As an alternative, you can combine character tokens (<a href="apidocs/ml/alternet/parser/Grammar.CharToken.html"><tt>CharToken</tt></a>) directly :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //    VARIABLE ::= (LOWERCASE | UPPERCASE) (LOWERCASE | UPPERCASE | DIGIT | UNDERSCORE)*
    Token VARIABLE = range('a', 'z').union('A', 'Z').seq(
            range('a', 'z').union('A', 'Z').union(DIGIT).union('_').zeroOrMore() )
            .asToken();
</pre></div></div>
<p><a href="apidocs/ml/alternet/parser/Grammar.CharToken.html"><tt>CharToken</tt></a> contains all the material to define and combine by inclusion <tt>union()</tt> or exclusion <tt>except()</tt> other ranges of characters.</p></div></div>
<div class="section">
<h3><a name="Rules"></a>Rules</h3>
<p>Now that we are able to split our input into tokens defined in our grammar, we can specify the <a href="apidocs/ml/alternet/parser/Grammar.Rule.html"><tt>Rule</tt>s</a> that tell how the input is structured.</p>
<p>A rule can be made of other rules and tokens. They are wired together by a connector that can be the alternative connector (&#x201c;|&#x201d; character in most formal grammar languages) or the sequential connector (a space in most grammars). In java, we have counterparts methods (<a href="apidocs/ml/alternet/parser/Grammar.Rule.html#or-ml.alternet.parser.Grammar.Rule...-"><tt>or()</tt></a> and <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#seq-ml.alternet.parser.Grammar.Rule...-"><tt>seq()</tt></a>) for that.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //   Value ::=  NUMBER  |  VARIABLE
    Rule Value   = (NUMBER).or(VARIABLE);
</pre></div></div>
<p>We can combine several tokens ; say that we defined the tokens T1, T2, etc :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // MyRule ::=  T1  |  T2  |  T3  |  T4  |  T5
    Rule MyRule = (T1).or(T2).or(T3).or(T4).or(T5);
</pre></div></div>
<p>or more consicely :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //   MyRule ::= T1 |  T2 | T3 | T4 | T5
    Rule MyRule   = T1.or(T2,  T3,  T4,  T5);
</pre></div></div>
<p>The <tt>or()</tt> method is lazy : while parsing, the first rule that will match the input will fulfill the production rule.</p>

<div class="alert alert-error" role="alert">
As a consequence, grammars expressed with :

<div class="source">
<div class="source">
<pre class="prettyprint">
// [1]     Items    ::=      ITEM | Items ',' ITEM
</pre></div></div>
must be rewrite to :

<div class="source">
<div class="source">
<pre class="prettyprint">
// [1]     Items    ::=      ITEM ( ',' ITEM )*
</pre></div></div>
</div>
<p>Similarly, for a sequence we write :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //   MyRule ::=  T1      T2      T3      T4      T5
    Rule MyRule   = (T1).seq(T2).seq(T3).seq(T4).seq(T5);
</pre></div></div>
<p>or more consicely :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //   MyRule ::= T1     T2  T3  T4  T5
    Rule MyRule   = T1.seq(T2, T3, T4, T5);
</pre></div></div>
<p>The thing to notice when writing grammars in Alternet Parsing, is that you write rules in the same order where they appear in the formal grammar language.</p>
<p>Rule parts can be combined together, and combined with operators such as * ? or +, that have their counterpart Java methods :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // RuleA ::= T1 *
    Rule RuleA = T1.zeroOrMore();
    // RuleB ::= T1 ?
    Rule RuleB = T1.optional();
    // RuleC ::= T1 +
    Rule RuleC = T1.oneOrMore();

    // RuleD ::= T1 ? | T2 +
    Rule RuleD = T1.optional().or( T2.oneOrMore() );
    // RuleE ::= (T1 ? | T2) +
    Rule RuleE = T1.optional().or(T2).oneOrMore();
</pre></div></div>
<p>Notice how we wrote the 2 last rules. Remember that we are expressing rules in the Java language, and that the &#x201c;.&#x201d; (dot) operator in Java applies a method on the previously given object. Therefore, when we write <tt>.or( T2.oneOrMore() )</tt> the <tt>oneOrMore()</tt> method applies on <tt>T2</tt> only, and when we write <tt>.or(T2).oneOrMore()</tt> this time the <tt>oneOrMore()</tt> method applies to the result of the <tt>or()</tt> connector to which <tt>T2</tt> was connected, that is to say an optional <tt>T1</tt>.</p>
<p>Now we are able to write such rules, and when necessary to turn rules in tokens :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //    VARIABLE ::= (LOWERCASE | UPPERCASE) (LOWERCASE | UPPERCASE | DIGIT | UNDERSCORE)*
    Token VARIABLE = LOWERCASE.or(UPPERCASE).seq(
            LOWERCASE.or(UPPERCASE, DIGIT, UNDERSCORE).zeroOrMore() )
            .asToken();
</pre></div></div>
<div class="section">
<h4><a name="Self_rule_and_deferred_rules"></a>Self rule and deferred rules</h4>
<p>Let&#x2019;s go back in our grammar.</p>
<p>We have all the material to write rules like this :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Expression ::= Sum
    Rule Expression = is(Sum); // &#x26d4; you can't write that in Java

    //   Argument ::= FUNCTION     Argument  |   Value   |   LBRACKET      Expression  RBRACKET
    Rule Argument =   FUNCTION.seq(Argument).or( Value ).or( LBRACKET.seq( Expression, RBRACKET ) );
                                 // &#x26d4; you can't write that either
</pre></div></div>
<p>Unfortunately, this writing <i>fails</i>, because we are in a Java program, and we can&#x2019;t define a field (actually <tt>Argument</tt>) by being a composition of itself. You can&#x2019;t either define a field (actually <tt>Expression</tt>) being composed of other rules that are not yet defined. Actually <tt>Sum</tt> has not yet been defined. We could define it before, but a <tt>Sum</tt> will be made sooner or later of <tt>Expression</tt>s (indirectly).</p>

<div class="alert alert-info" role="alert">
It's not rare to see grammars defining rules that are referring each others or rules that are referring themselves.
</div>
<p>Note that the following fix also <i>fail</i> because the value of the <tt>Sum</tt> field, although correctly referred is not yet assigned and a <tt>null</tt> value would be passed :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Expression ::=      Sum
    Rule Expression = is(Calc.Sum); // &#x26d4; in fact we have null
</pre></div></div>
<p>To fix this, we introduce <tt>$(&quot;Sum&quot;)</tt> and <tt>$(&quot;Argument&quot;)</tt> that are placeholder for rules not yet defined or defined later in our Java program :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Expression ::=    Sum
    Rule Expression = $(&quot;Sum&quot;);
    //   Argument ::= FUNCTION        Argument  |     Value   |   LBRACKET      Expression  RBRACKET
    Rule Argument =   FUNCTION.seq($(&quot;Argument&quot;)).or( Value ).or( LBRACKET.seq( Expression, RBRACKET ) );
</pre></div></div>
<p>The built-in token <tt>$self</tt> can be used instead of <tt>$(&quot;Argument&quot;)</tt> within the definition of the field <tt>Argument</tt> :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Expression ::=    Sum
    Rule Expression = $(&quot;Sum&quot;);
    //   Argument ::= FUNCTION    Argument  |   Value   |   LBRACKET      Expression  RBRACKET
    Rule Argument =   FUNCTION.seq( $self ).or( Value ).or( LBRACKET.seq( Expression, RBRACKET ) );
</pre></div></div>
<p><tt>$(&quot;Sum&quot;)</tt> stands for a reference to the following rule declaration :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Sum ::= SignedTerm (ADDITIVE Product)*
    Rule Sum = SignedTerm.seq(ADDITIVE.seq(Product).zeroOrMore());
</pre></div></div>
<p>(at this time we assume that <tt>SignedTerm</tt> and <tt>Product</tt> have been already defined).</p></div>
<div class="section">
<h4><a name="Proxy_rules"></a>Proxy rules</h4>
<p>If you are in trouble by writing <tt>$(&quot;Sum&quot;)</tt> (which reduce the ease of reading), you can instead define it previously by being a proxy rule:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Proxy Sum = $(); // we expect a definition later
    // Expression ::=    Sum
    Rule Expression = is(Sum);
    //   Argument ::= FUNCTION    Argument  |   Value   |   LBRACKET      Expression  RBRACKET
    Rule Argument =   FUNCTION.seq( $self ).or( Value ).or( LBRACKET.seq( Expression, RBRACKET ) );
</pre></div></div>
<p>&#x2026;and later in the grammar, you supply its definition when appropriate. You can write it in 3 different flavors, plus the possibility to write it inline :</p>

<ul>
  
<li>The former writing consist on mimicking a static block :</li>
</ul>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    boolean b1 = 
    // Sum ::= SignedTerm (ADDITIVE Product)*
    Sum.is(
        SignedTerm.seq(ADDITIVE.seq(Product).zeroOrMore())
    );
</pre></div></div>
<p>Why do we have a boolean ? In fact we just want to set a value to <tt>Sum</tt>, but since it has already been defined before, this writing is just a convenient way with Java to supply its value ; since an interface can&#x2019;t have static blocks, we are creating a dummy field <tt>b1</tt>.</p>

<ul>
  
<li>The second writing consist on declaring a STATIC method that has the same name of the field, actually <tt>Sum()</tt>, that return the actual rule.</li>
</ul>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Sum ::= SignedTerm (ADDITIVE Product)*
    static Rule Sum() {
        return SignedTerm.seq(ADDITIVE.seq(Product).zeroOrMore());
    }
</pre></div></div>

<ul>
  
<li>The latter writing consist on declaring a property that has the same name of the field prepend with $, actually <tt>$Sum</tt>, this property being a supplier of the expected rule.</li>
</ul>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Sum ::= SignedTerm (ADDITIVE Product)*
    Supplier&lt;Rule&gt; $Sum = () -&gt; SignedTerm.seq(ADDITIVE.seq(Product).zeroOrMore());
</pre></div></div>

<ul>
  
<li>Alternatively, you can also supply the definition <i>inline</i>, at the place the rule field is declared. In that case, each field not yet defined in the grammar has to be taken from the grammar class ; in our example the fields <tt>SignedTerm</tt> and <tt>Product</tt> have not yet been defined, and we must refer them as class members : <tt>Calc.SignedTerm</tt> and <tt>Calc.Product</tt>.</li>
</ul>
<p>Unlike previously, we don&#x2019;t get null values because the supplier is a deferred method that will set the rule definition after all fields initialization :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Sum ::= SignedTerm (ADDITIVE Product)*
    Rule Sum = $(() -&gt; 
               Calc.SignedTerm.seq(ADDITIVE.seq(Calc.Product).zeroOrMore())
    );
    // Expression ::=    Sum
    Rule Expression = is(Sum);
    //   Argument ::= FUNCTION    Argument  |   Value   |   LBRACKET      Expression  RBRACKET
    Rule Argument =   FUNCTION.seq( $self ).or( Value ).or( LBRACKET.seq( Expression, RBRACKET ) );
</pre></div></div>
<p>The advantage of this writing is that the rule is defined in place, but at the cost of extra syntax.</p>
<p>Choose your style of writing : <tt>$()</tt> with its inline or deferred assignment is interchangeable with <tt>$(&quot;foo&quot;)</tt> with a normal definition.</p>
<p>Now you should be able to write yourself the remaining rules. The complete code of <tt>Calc</tt> grammar is available on Github.</p></div>
<div class="section">
<h4><a name="Direct_reference"></a>Direct reference</h4>
<p>Now that we are able to write</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Expression ::=    Sum
    Rule Expression = is(Sum);
</pre></div></div>
<p>you might wonder why we didn&#x2019;t write it like that :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Expression ::=    Sum
    Rule Expression = Sum; // &#x26d4; you will have an error
</pre></div></div>
<p>The engine won&#x2019;t let you write that and reject such grammar. Rules must hold a specific value, not identical values because if one rule was annotated, it would affect both fields.</p></div>
<div class="section">
<h4><a name="Handling_whitespaces"></a>Handling whitespaces</h4>
<p>In fact, we would like to parse inputs like this :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">sin (x) * ( 1 + var_12 )
</pre></div></div>
<p>So simple in Alternet Parsing ;)</p>
<p>By default, whitespaces are left as-is, but if you want to ignore them, simply set this annotation to your grammar :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">@WhitespacePolicy(preserve=false, isWhitespace=ml.alternet.scan.JavaWhitespace.class)
public interface Calc extends Grammar {

    // tokens and rules definition here

    Calc $ = $();
}
</pre></div></div>
<p>In fact, the values above are the default, therefore, you can simply write :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">@WhitespacePolicy
public interface Calc extends Grammar {

    // tokens and rules definition here

    Calc $ = $();
}
</pre></div></div>
<p>Another kind of whitespaces are pre-defined, it is <tt>ml.alternet.scan.XMLWhitespace.class</tt> but you can write your own class, it just has to implement <tt>Predicate&lt;Character&gt;&gt;</tt>.</p>
<p>But wait, setting the <tt>@WhitespacePolicy</tt> annotation on the grammar affect every token. It&#x2019;s nice for the <tt>NUMBER</tt> token, but not appropriate for what it is made of, the <tt>DIGIT</tt> tokens. In the grammar, we have to change accordingly on its declaration :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // DIGIT ::= [0-9]
    @WhitespacePolicy(preserve=true)
    @Fragment Token DIGIT = range('0', '9').asNumber();

    // NUMBER ::= DIGIT+
    Token NUMBER = DIGIT.oneOrMore()
            .asNumber();
</pre></div></div>
<p>Now, whereas <tt>NUMBER</tt> inherit the whitespace policy defined by the grammar, <tt>DIGIT</tt> override it with its own requirements. In our grammar we are setting <tt>@WhitespacePolicy(preserve=true)</tt> on other fragments tokens, actually <tt>UPPERCASE</tt>, <tt>LOWERCASE</tt>, and <tt>UNDERSCORE</tt>.</p></div>
<div class="section">
<h4><a name="Extending_grammars_and_overriding_rules"></a>Extending grammars and overriding rules</h4>
<p>It is possible to extend a grammar by adding new rules and tokens, but also to redefine some of them.</p>
<p>Imagine that we want to write a grammar that is almost the same as the <tt>Calc</tt> grammar, but with different rules :</p>

<ul>
  
<li>having more built-in functions</li>
  
<li>change the tokens <tt>*</tt> and <tt>/</tt> by <tt>&#xd7;</tt> and <tt>&#xf7;</tt></li>
  
<li>disallow lowercase characters in variable names</li>
  
<li>surround function arguments with parentheses</li>
</ul>
<p>Here are the changes :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
[03] FUNCTION       ::= 'sin' | 'cos' | 'exp' | 'ln' | 'sqrt' | 'asin' | 'acos'
[05] MULTIPLICATIVE ::= '&#xd7;' | '&#xf7;'
[11] VARIABLE       ::= UPPERCASE (UPPERCASE | DIGIT | UNDERSCORE)*

[14] Argument       ::= FUNCTION '(' Argument ')' | Value | '(' Expression ')'
</pre></div></div>
<p>To achieve this, the new grammar have just to extend the previous one :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public interface Math extends Calc { // &#x1f448; look here, we extend Calc

    // new rules and tokens here

    Math $ = $();

}
</pre></div></div>
<p>Then it have to contain the new definitions.</p>
<p>If the new field have the same name as an existing field in the other grammar, it is replacing it :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // MULTIPLICATIVE ::= '&#xd7;' | '&#xf7;'
    enum MathMultiplicative {
        MULT(&quot;&#xd7;&quot;), DIV(&quot;&#xf7;&quot;);
        MathMultiplicative(String str) {
            replace(MathMultiplicative.class, this, s -&gt; str);
        }
    }
    // same name than in Calc grammar -&gt; automatic replacement
    Token MULTIPLICATIVE = is(MathMultiplicative.class);
</pre></div></div>
<p>If the new field has another name, we have to specify which one it is replacing. Below, everywhere <tt>UPPERCASE</tt> appears in the <tt>Calc</tt> grammar, it will be replaced by <tt>UPPERCASE_VARIABLE</tt> in the <tt>Math</tt> grammar (and stay unchanged in the <tt>Calc</tt> grammar) :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // VARIABLE ::= [A-Z] ([A-Z] | DIGIT | '_')*
    @Replace(field=&quot;VARIABLE&quot;)
    Token UPPERCASE_VARIABLE = UPPERCASE.seq(
            UPPERCASE.or(DIGIT, UNDERSCORE).zeroOrMore() )
            .asToken();
</pre></div></div>
<p>Sometimes, you have to extend several grammars that may have fields with the same name ; in this case, you also have to specify the appropriate grammar :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // FUNCTION ::= 'sin' | 'cos' | 'exp' | 'ln' | 'sqrt' | 'asin' | 'acos'
    enum MathFunction {
        sin, cos, exp, ln, sqrt, asin, acos;
    }
    @Replace(field=&quot;FUNCTION&quot;, grammar=Calc.class)
    Token ADVANCED_FUNCTION = is(MathFunction.class);
</pre></div></div>
<p>You don&#x2019;t need to rewrite the rules where those new definitions are used, they will be replaced in the new grammar. Of course, the original grammar will stay unchanged.</p>
<p>Here is a parsing example with each grammar :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Calc.$.parse(Scanner.of(&quot;sin( x ) * ( 1 + var_12 )&quot;), handler);
    Math.$.parse(Scanner.of(&quot;asin( X ) &#xd7; ( 1 + VAR_12 )&quot;), handler);
</pre></div></div></div>
<div class="section">
<h4><a name="A_grammar_as_a_token"></a>A grammar as a token</h4>
<p>Sometimes it is preferable to expose a grammar as a token rather than extending an existing grammar.</p>
<p>For example, imagine that our expression <tt>sin( x ) * ( 1 + var_12 )</tt> always appear in fact in value templates, delimited with <tt>{</tt> and <tt>}</tt> like this :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
the result of the expression sin(x)*(1+var_12) is { sin(x)*(1+var_12) } !
</pre></div></div>
<p>Everything between the curly braces is the expression, and everything around is just text, and after parsing and evaluating, we expect an output like this :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
the result of the expression sin(x)*(1+var_12) is 42 !
</pre></div></div>
<p>(as an exercise you can find a couple for x and var_12 that gives 42)</p>
<p>To achieve this, we need a new grammar, but instead of extending our <tt>Calc</tt> grammar, we simply expose it as a token :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public interface ValueTemplate extends Grammar {

    @Fragment Token LCB = is('{');
    @Fragment Token RCB = is('}');

    Token ESCAPE_LCB = is(&quot;{{&quot;); // a double {{ is an escape for {
    Token ESCAPE_RCB = is(&quot;}}&quot;); // a double }} is an escape for }

    //   EXPRESSION ::= Calc
    Token EXPRESSION = is(
            Calc.$,
            () -&gt; new ExpressionBuilder());

    Rule Text = ESCAPE_LCB.or(ESCAPE_RCB, isnot(LCB, RCB)).zeroOrMore();

    @MainRule
    Rule ValueTemplate = Text.seq(EXPRESSION.optional()).zeroOrMore();

    ValueTemplate $ = $();

}
</pre></div></div>
<p>We will learn later about <tt>ExpressionBuilder()</tt>, it is just the handler that we create in order to built an AST.</p>
<p>This approach is preferable than extending a grammar when the target result type differs from the other grammar. In our case, an expression is evaluated to a number, whereas a value template expression is evaluated to a string.</p>
<p>In the next section we will learn how to build a custom data model.</p></div></div>
<div class="section">
<h3><a name="Grammar_with_custom_token_types"></a>Grammar with custom token types</h3>
<p>A token value represent the input characters that are parsed. We have seen before that a token value may have various types :</p>

<ul>
  
<li>a single character : this is the default behaviour. E.g. <tt>&quot;(&quot;</tt></li>
  
<li>a string : this is also the default behaviour when a sequence is matched. E.g. <tt>&quot;var_12&quot;</tt></li>
  
<li>a number : when it is specified by <tt>.asNumber()</tt>. E.g. <tt>123.45</tt></li>
  
<li>an enum value : when the token is defined with an enum class. E.g. <tt>Axis.ancestor_or_self</tt></li>
</ul>
<p>It is also possible to specify in the grammar :</p>

<ul>
  
<li>characters that we want to skip. E.g. <tt>&quot;\\&quot;</tt> where the first <tt>\</tt> stand for an escape character and the second <tt>\</tt> for the data.</li>
  
<li>characters rendered as a custom object. E.g. our class <tt>Challenge</tt> defined here after.</li>
</ul>
<p>Let&#x2019;s show how.</p>
<p>In this example, we intend to parse the WWW-Authenticate header sent by an HTTP server in a response 401 : &#xab; Unauthorized &#xbb;, that indicates how the client can authenticate :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
# Challenge Basic
WWW-Authenticate: Basic realm=&quot;FooCorp&quot;
 
# Challenge OAuth 2.0 apr&#xe8;s l'envoi d'un token expir&#xe9;
WWW-Authenticate: Bearer realm=&quot;FooCorp&quot;, error=invalid_token, error_description=&quot;The \&quot;access token\&quot; has expired&quot;
</pre></div></div>
<p>We will design our <tt>WAuth</tt> grammar and our custom result objects, say the <tt>Challenge</tt> class for the global result and the <tt>Parameter</tt> class for each {name, value} pair.</p>
<div class="section">
<h4><a name="The_target_custom_classes"></a>The target custom classes</h4>
<p>Our custom classes, first, are very simple ; notice they are agnostic regarding our future grammar, they are just POJOs :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public class Parameter {

    public String name;  // e.g. &quot;realm&quot;
    public String value; // e.g. &quot;FooCorp&quot;

    public Parameter(String name, String value) {
        this.name = name;
        this.value = value;
    }
}
</pre></div></div>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public class Challenge {

    public String scheme; // e.g. &quot;Basic&quot;
    public List&lt;Parameter&gt; parameters;

    public Challenge(String scheme, List&lt;Parameter&gt; parameters) {
        this.scheme = scheme;
        this.parameters = parameters;
    }

}
</pre></div></div></div>
<div class="section">
<h4><a name="The_WAuth_grammar"></a>The WAuth grammar</h4>
<p>Now, the grammar :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    # from RFC-2617 (HTTP Basic and Digest authentication)

    challenge      = auth-scheme 1*SP 1#auth-param
    auth-scheme    = token
    auth-param     = token &quot;=&quot; ( token | quoted-string )

    # from RFC2616 (HTTP/1.1)

    token          = 1*&lt;any CHAR except CTLs or separators&gt;
    separators     = &quot;(&quot; | &quot;)&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;@&quot;
                   | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &lt;&quot;&gt;
                   | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;
                   | &quot;{&quot; | &quot;}&quot; | SP | HT
    quoted-string  = ( &lt;&quot;&gt; *(qdtext | quoted-pair ) &lt;&quot;&gt; )
    qdtext         = &lt;any TEXT except &lt;&quot;&gt;&gt;
    quoted-pair    = &quot;\&quot; CHAR
</pre></div></div></div>
<div class="section">
<h4><a name="Skipping_tokens"></a>Skipping tokens</h4>
<p>Let&#x2019;s start the Java grammar :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public interface WAuth extends Grammar {

    @Fragment Token SEPARATORS = isOneOf(&quot;()&lt;&gt;@,;:\\\&quot;/[]?={} \t&quot;);
    @Fragment Token CTRLS = range(0, 31).union(127); // octets 0 - 31 and DEL (127)

    @WhitespacePolicy(preserve=true)
    @Fragment Token TOKEN_CHAR = isNot(SEPARATORS, CTRLS);

    @WhitespacePolicy
    Token TOKEN = TOKEN_CHAR.oneOrMore()
            .asToken();

    @Fragment Token DOUBLE_QUOTE = is('&quot;');
    @Fragment Token BACKSLASH = is('\\')
            .skip();

    @WhitespacePolicy(preserve=true)
    @Fragment Token QuotedPair = BACKSLASH.seq($any).asToken();

    // other tokens here

    WAuth $ = $();

}
</pre></div></div>
<p>We defined various tokens as ranges of characters, and tokens made of other tokens. <tt>$any</tt> is a built-in token that matches any character. Remember that as soon as you use modifiers such as <tt>.oneOrMore()</tt> or combiners such as <tt>.seq()</tt> you get a <tt>Rule</tt>, but you can turn it back to a <tt>Token</tt> with <tt>.asToken()</tt>. Notice that the <tt>BACKSLASH</tt> token is skipped with <tt>.skip()</tt>. It means that the handler won&#x2019;t ever received this token, but the grammar ensure that the following character is properly escaped, and that the relevant value received is properly stripped from the <tt>\</tt> character.</p>
<p>Conversely, the <tt>DOUBLE_QUOTE</tt> token is not skipped at the token definition, because sometimes it stands for a delimiter (and in that case it has to be removed), and some other times it stands for itself (as <tt>&quot;</tt>). Therefore, we use <tt>.skip()</tt> at the places we don&#x2019;t want to get <tt>&quot;</tt> as data :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    @WhitespacePolicy(preserve=true)
    @Fragment Token QdText = isNot(DOUBLE_QUOTE);

    Token QuotedString = DOUBLE_QUOTE.skip().seq( // &quot; is a separator
            QuotedPair.or(QdText).zeroOrMore(),
            DOUBLE_QUOTE.skip())                  // &quot; is a separator too
        .asToken();

    Token ParameterValue = TOKEN.or(QuotedString).asToken();

    @Fragment Token EQUAL = is('=');
</pre></div></div></div>
<div class="section">
<h4><a name="Mapping_tokens"></a>Mapping tokens</h4>
<p>We already used <tt>.asNumber()</tt> for getting a number value and <tt>.asToken()</tt> for turning a rule to a token ; now we will use <tt>.asToken(mapper)</tt> to turn the tokens of a rule to a custom object. Actually, we expect our <tt>Parameter</tt> object, and we have a special type for the counterpart definition : <tt>TypedToken&lt;Parameter&gt;</tt>. The mapper is just a function that takes as argument the <tt>List</tt> of tokens parsed by the rule and that returns a value that can be consumed by the enclosing rule.</p>
<p>Below, the rule will match <tt>aName = aValue</tt> in 3 tokens, and we produced a <tt>Parameter</tt> object with the first and the last tokens ; the <tt>=</tt> token is ignored, no need to use <tt>.skip()</tt> on it (but you could, it wouldn&#x2019;t change anything).</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //                    Parameter ::= TOKEN     EQUAL  ParameterValue
    TypedToken&lt;Parameter&gt; Parameter =   TOKEN.seq(EQUAL, ParameterValue)  // e.g. &quot;aName = aValue&quot;
        .asToken(tokens -&gt;
            new Parameter(
                    tokens.getFirst().getValue(), // TOKEN
                    tokens.getLast().getValue()   // ParameterValue
        ));
</pre></div></div>
<p>Similarly, a list of parameters can be produced easily, but since we don&#x2019;t know how many tokens will be available, we are streaming the list of tokens. Since the <tt>Parameters</tt> rule is made of <tt>Parameter</tt> rules that create new instances of our <tt>Parameter</tt> POJO (yes, we have the same name for a rule and our POJO), we can safely cast the token value. Below, instead of skipping the <tt>COMMA</tt> token, as an alternative we filtered it while processing the stream :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    @WhitespacePolicy
    @Fragment Token COMMA = is(',');

    //                          Parameters ::= Parameter    (COMMA     Parameter?)*
    TypedToken&lt;List&lt;Parameter&gt;&gt; Parameters =   Parameter.seq(COMMA.seq(Parameter.optional()).zeroOrMore())
        .asToken(tokens -&gt;
                tokens.stream()
                    // drop &quot;,&quot;
                    .filter(t -&gt; t.getRule() != COMMA)
                    // extract the value as a Parameter object
                    .map(t -&gt; (Parameter) t.getValue())
                    .collect(toList())
        );
</pre></div></div>
<p>It&#x2019;s worth to mention that the token values available in the list are instances of <a href="apidocs/ml/alternet/parser/EventsHandler.TokenValue.html"><tt>TokenValue&lt;V&gt;</tt></a> from which you can extract the rule/token that matched the input (<tt>.getRule()</tt>) and the actual value (<tt>.getValue()</tt>). You can aslo retrieve the type of the value or set a new value.</p>
<p>Finally, the production of the <tt>Challenge</tt> is obvious. It is marked as the main rule of our grammar :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //                    Challenge ::= TOKEN     Parameters
    @MainRule
    TypedToken&lt;Challenge&gt; Challenge =   TOKEN.seq(Parameters)
        .asToken(tokens -&gt; new Challenge(
                tokens.removeFirst().getValue(), // TOKEN
                tokens.removeFirst().getValue()) // Parameters
            );
</pre></div></div>
<p>In a nutshell, the line #3 that defines the rule refers to other rules or tokens. The lines #4 to #7 that create an object refers to other objects previsouly created.</p>
<p>Now we can create a parser (outside of our grammar), to get optionally our challenge (it is optional because the parsing may fail) :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public class WAuthParser {

    public Challenge parse(String input) {
        Optional&lt;Challenge&gt; result = new NodeBuilder&lt;Challenge&gt;(WAuth.$).build(input, true);
        return result.get(); // or throw an error
    }
}
</pre></div></div>
<p>We are using the <tt>NodeBuilder&lt;T&gt;</tt> class that can supply an instance of <tt>T</tt> if the parsing succeeds, actually our POJO <tt>Challenge</tt>. The boolean parameter indicates when set to <tt>true</tt> to consume all the characters from the input (it would be a failure if some characters remain at the end).</p></div></div>
<div class="section">
<h3><a name="Parsing_an_input"></a>Parsing an input</h3>
<p>An input can be parsed :</p>

<ul>
  
<li>on a special rule that stands for the main rule</li>
  
<li>on any of the token rules</li>
  
<li>on a given rule</li>
</ul>
<p>We have a grammar interface, and a field which is an instance of that grammar. From that instance, we can parse an input on a given rule, actually the <tt>Expression</tt> rule :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Handler handler = ...;
    String input = &quot;sin(x)*(1+var_12)&quot;;
    CalcGrammar.Calc.parse(Scanner.of(input), handler, CalcGrammar.Expression);
</pre></div></div>
<p>The handler is the component that accept the parsing result (more about that on see next section).</p>
<p>If we consider that the field <tt>Expression</tt> is the main rule in our grammar, we can annotate it like this :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    @MainRule Rule Expression = $(&quot;SignedTerm&quot;).seq($(&quot;SumOp&quot;));
</pre></div></div>
<p>If the <tt>parse()</tt> method is invoked without specifying any rule, the main rule will be used :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Handler handler = ...;
    String input = &quot;sin(x)*(1+var_12)&quot;;
    CalcGrammar.Calc.parse(Scanner.of(input), handler);
</pre></div></div>
<div class="section">
<h4><a name="The_tokenizer_rule"></a>The &#x201c;tokenizer&#x201d; rule</h4>
<p>A special rule is available in every grammar, it is the rule that takes all the tokens that are not fragment :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Handler handler = ...;
    String input = &quot;sin(x)*(1+var_12)&quot;;
    CalcGrammar.Calc.parse(Scanner.of(input), handler, CalcGrammar.tokenizer());
</pre></div></div>
<p>The tokenizer will match tokens regardlesss the structure, therefore inputs badly structured can be parsed, but you will be sure that the input is made of valid tokens.</p>
<p><a name="parsing-tutorial"></a></p></div></div></div>
<div class="section">
<h2><a name="Parsing_tutorial"></a>Parsing tutorial</h2>
<p>Alternet Parsing comes with an out-of-the-box <a href="apidocs/ml/alternet/parser/TreeHandler.html"><tt>TreeHandler</tt></a> that can receive the result of the parsing, that will be handy for processing that result :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    TreeHandler handler = new TreeHandler();
</pre></div></div>
<p>In that tree, we will store items that we want to process, and ignore others.</p>
<p>If we look at the formal grammar at the beginning, we should notice that some other tokens are also not useful after parsing. The left/right brackets are useful during parsing, but since the grammar ensure that pairs of left/right brackets are well-balanced, we can ignore them in the result tree because we don&#x2019;t need them anymore.</p>
<p>Like previously, we can mark them as <tt>@Fragment</tt>, the consequence is they won&#x2019;t be reported to the tree handler :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    @Fragment Token LBRACKET = is('(');
    @Fragment Token RBRACKET = is(')');
</pre></div></div>
<p>Similarly, some rules are used during parsing, but not so useful after parsing. We can also mark them as <tt>@Fragment</tt>, they won&#x2019;t be reported to the handler, they&#x2019;ll just be involved during parsing.</p>
<p>The following rules have been identified as being fragments :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // we just need to know whether we have a number or a variable
    @Fragment Rule Value = NUMBER.or(VARIABLE);
    
    // we are interested in the components of the arguments, not on the rule itself
    @Fragment Rule Argument = Value.or( FUNCTION.seq($self) ).or( LBRACKET.seq( $(&quot;Expression&quot;), RBRACKET ) );
</pre></div></div>
<p>To help you decide whether a rule has to be a fragment, just consider that if you intend to make some processing on a Rule or Token, keep it in the result tree, otherwise, mark it as fragment.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    TreeHandler handler = new TreeHandler();
    String input = &quot;sin(x)*(1+var_12)&quot;;
    CalcGrammar.Calc.parse(Scanner.of(input), handler);
</pre></div></div>
<p>TODO Bridge between the grammar and the data model =&gt; producing instances (or not) when the rule matched</p></div>
        </div>
    </div>
    <hr/>
    <footer>
      <div class="container">
        <div class="row">
            <p>Copyright &copy;2017
<a href="http://alternet.ml">Alternet</a>.
All rights reserved.</p>
        </div>
        <p id="poweredBy" class="pull-right">  <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
  </p>
        </div>
    </footer>
    </body>
</html>
