<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.7.4 at 2018-03-27 
 | Rendered using Apache Maven Fluido Skin 1.6
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20180327" />
    <meta http-equiv="Content-Language" content="en" />
    <title>Alternet Parsing &#x2013; Grammars and Parsers</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.6.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
      <script type="text/javascript" src="./js/apache-maven-fluido-1.6.min.js"></script>
<link rel="stylesheet" href="../css/site.css" />
      </head>
    <body class="topBarEnabled">
      <div id="topbar" class="navbar navbar-fixed-top ">
      <div class="navbar-inner">
            <div class="container"><div class="nav-collapse">
            <ul class="nav">
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Main <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../" title="Home">Home</a></li>
            <li><a href="https://github.com/alternet/alternet.ml" title="GitHub project">GitHub project</a></li>
            <li><a href="http://semantic-mismatch.blogspot.fr/" title="Blog">Blog</a></li>
            <li><a href="../release-notes.html" title="Release notes">Release notes</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Download <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../download.html" title="Download">Download</a></li>
            <li><a href="../license.html" title="License">License</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../parsing/index.html" title="Alternet Parsing">Alternet Parsing</a></li>
            <li><a href="../scanner/index.html" title="Alternet Scanner">Alternet Scanner</a></li>
            <li><a href="../security/index.html" title="Alternet Security">Alternet Security</a></li>
            <li><a href="../tools/index.html" title="Alternet Tools">Alternet Tools</a></li>
            <li><a href="../tools-generator/index.html" title="Alternet Tools - Generator">Alternet Tools - Generator</a></li>
            <li><a href="../prop-bind-maven-plugin/index.html" title="Properties Binder Maven Plugin">Properties Binder Maven Plugin</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Maven reports <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li class="dropdown-submenu">
<a href="project-info.html" title="Project Information">Project Information</a>
              <ul class="dropdown-menu">
                  <li><a href="project-summary.html" title="Summary">Summary</a></li>
                  <li><a href="license.html" title="Licenses">Licenses</a></li>
                  <li><a href="team-list.html" title="Team">Team</a></li>
                  <li><a href="source-repository.html" title="Source Code Management">Source Code Management</a></li>
                  <li><a href="issue-tracking.html" title="Issue Management">Issue Management</a></li>
                  <li><a href="dependencies.html" title="Dependencies">Dependencies</a></li>
                  <li><a href="dependency-convergence.html" title="Dependency Convergence">Dependency Convergence</a></li>
                  <li><a href="plugins.html" title="Plugins">Plugins</a></li>
              </ul>
            </li>
            <li class="dropdown-submenu">
<a href="project-reports.html" title="Project Reports">Project Reports</a>
              <ul class="dropdown-menu">
                  <li><a href="apidocs/index.html" title="Javadoc">Javadoc</a></li>
                  <li><a href="xref/index.html" title="Source Xref">Source Xref</a></li>
                  <li><a href="xref-test/index.html" title="Test Source Xref">Test Source Xref</a></li>
                  <li><a href="surefire-report.html" title="Surefire Report">Surefire Report</a></li>
                  <li><a href="pmd.html" title="PMD">PMD</a></li>
                  <li><a href="checkstyle.html" title="Checkstyle">Checkstyle</a></li>
              </ul>
            </li>
        </ul>
      </li>
              </ul>
                    <ul class="nav pull-right">
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">External Links <b class="caret"></b></a>
                <ul class="dropdown-menu">
    <li><a href="https://github.com/alternet/alternet.ml" title="GitHub project">GitHub project</a></li>
    <li><a href="../demo.html" title="Other Demos">Other Demos</a></li>
                </ul>
              </li>
            </ul>
            </div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>Alternet Parsing</h2>
</div>
</div>
        <div class="pull-right"></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2018-03-27<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.0<span class="divider">|</span></li>
        <li class=""><a href="../.." title="Alternet">Alternet</a><span class="divider">»</span></li>
      <li class=""><a href="../index.html" title="Alternet Libs">Alternet Libs</a><span class="divider">»</span></li>
      <li class=""><a href="index.html" title="Alternet Parsing">Alternet Parsing</a><span class="divider">»</span></li>
    <li class="active ">Grammars and Parsers</li>
        </ul>
      </div>
        <div id="bodyColumn" >
<h1>Grammars and Parsers</h1>

<div class="scroller"></div>

<div class="nopub">
<a class="externalLink" href="http://alternet.ml/alternet-libs/parsing/parsing.html">
Published version of this page available HERE</a></div>
<p><b>Alternet Parsing</b> is a nice <a class="externalLink" href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">Parsing Expression Grammar</a> framework that includes an Abstract Syntax Tree builder.</p>

<ol style="list-style-type: decimal">
  
<li><a href="#overview">Overview</a>
  
<ol style="list-style-type: decimal">
    
<li><a href="#features">Features</a></li>
  </ol></li>
  
<li><a href="#grammars">Grammars</a>
  
<ol style="list-style-type: decimal">
    
<li><a href="#skeleton">The grammar skeleton</a></li>
    
<li><a href="#tokens">Tokens</a>
    
<ol style="list-style-type: decimal">
      
<li><a href="#enumTokens">Enum tokens</a></li>
      
<li><a href="#fragments">Fragment tokens and composed tokens</a></li>
      
<li><a href="#charTokens">Char tokens</a></li>
    </ol></li>
    
<li><a href="#rules">Rules</a>
    
<ol style="list-style-type: decimal">
      
<li><a href="#repeating">Repeating</a></li>
      
<li><a href="#self">Self rule and deferred rules</a></li>
      
<li><a href="#proxy">Proxy rules</a></li>
      
<li><a href="#directRef">Direct reference</a></li>
      
<li><a href="#whitespaces">Skipping whitespaces and other characters</a></li>
      
<li><a href="#extending">Extending grammars and overriding rules</a></li>
    </ol></li>
  </ol></li>
  
<li><a href="#customTypes">Grammar with custom token types</a>
  
<ol style="list-style-type: decimal">
    
<li><a href="#targetClasses">The target custom classes</a></li>
    
<li><a href="#drop">Dropping tokens</a></li>
    
<li><a href="#mapping">Mapping tokens</a></li>
    
<li><a href="#augmented">Separating the raw grammar and the augmented grammar</a></li>
  </ol></li>
  
<li><a href="#parsing">Parsing</a>
  
<ol style="list-style-type: decimal">
    
<li><a href="#standalone">Parsing a standalone grammar</a></li>
    
<li><a href="#input">Parsing an input</a>
    
<ol style="list-style-type: decimal">
      
<li><a href="#mainRule">The &#x201c;main&#x201d; rule</a></li>
      
<li><a href="#tokenizer">The &#x201c;tokenizer&#x201d; rule</a></li>
      
<li><a href="#remainder">The remainder</a></li>
    </ol></li>
    
<li><a href="#handlers">Handlers</a></li>
    
<li><a href="#dataModel">Target data model</a></li>
    
<li><a href="#ast">AST builder</a>
    
<ol style="list-style-type: decimal">
      
<li><a href="#nodeBuilder">Node builder</a></li>
      
<li><a href="#mappers">AST mappers</a></li>
      
<li><a href="#tokenMappers">Token mappers</a></li>
      
<li><a href="#ruleMappers">Rule mappers</a></li>
    </ol></li>
    
<li><a href="#grammarToken">A grammar as a token</a></li>
    
<li><a href="#extendingMapping">Extending the mappings</a></li>
  </ol></li>
  
<li><a href="#examples">Additional examples</a></li>
  
<li><a href="#troubleshooting">Troubleshooting</a>
  
<ol style="list-style-type: decimal">
    
<li><a href="#dump">Dump</a></li>
    
<li><a href="#issues">Common issues</a></li>
  </ol></li>
</ol>
<p><a name="overview"></a></p>
<div class="section">
<h2><a name="Overview"></a>Overview</h2>
<p>Some tools are already existing for designing grammars.</p>
<p><b>Alternet Parsing</b> takes the bet that you don&#x2019;t want to learn a new DSL (such as with the well-known ANTLR tool), and therefore allow you to write your grammar in pure Java code.</p>
<p><a name="features"></a></p>
<div class="section">
<h3><a name="Features"></a>Features</h3>
<p>A grammar in <b>Alternet Parsing</b> is just an interface, which allow to avoid pollute the code with Java modifiers (namely &#x201c;<tt>public static final</tt>&#x201d;) ; the other benefits with interfaces is that you can have multiple inheritence, which allow you to extend by composition new grammars. Overriding a rule is as simple as you expect.</p>
<p>A grammar in <b>Alternet Parsing</b> (almost) follows the way rules are written in grammar-formal languages, you are not lost by the order rules are written.</p>
<p>There are 3 main citizens in Alternet Parsing : the <a href="apidocs/ml/alternet/parser/Grammar.html"><tt>Grammar</tt></a>, the <a href="apidocs/ml/alternet/parser/Grammar.Rule.html"><tt>Rule</tt></a>, and the <a href="apidocs/ml/alternet/parser/Grammar.Token.html"><tt>Token</tt></a> (a token is also a rule).</p>
<p>Alternet Parsing comes with out-of-the-box convenient features such as :</p>

<ul>
  
<li>no boilerplate code</li>
  
<li>easy parsing of enum values and ranges of characters (combination by union and exclusion)</li>
  
<li>rules written in Java are following the natural writing of (most) formal grammar languages</li>
  
<li>easy extension, combining facilities, and overriding</li>
  
<li>can scan strings or streams of characters</li>
  
<li>whitespace skipping set by annotation on a grammar and overridable on any token</li>
  
<li>clean separation of grammar and parser</li>
  
<li>nice token to custom object mappings facilities</li>
  
<li>out-of-the-box abstract syntax tree builder</li>
  
<li>etc&#x2026;</li>
</ul>

<div style="columns: 2">

<div>
</div>
<div class="section" style="margin: 0">
<h3 style="margin: 0"><a name="Maven_import"></a>Maven import</h3>

<div>
<pre class="prettyprint">
&lt;dependency&gt;
    &lt;groupId&gt;ml.alternet&lt;/groupId&gt;
    &lt;artifactId&gt;alternet-parsing&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;
</pre></div>
</div>

<div style="break-before: column">
</div>
<div class="section">
<h3><a name="JavaDoc_API_documentation"></a>JavaDoc API documentation</h3>

<ul>
<li><a href="apidocs/index.html">Alternet Parsing</a></li></ul>

<p>Other Alternet APIs :</p>

<ul>
<li><a href="../apidocs/index.html">Alternet Libs</a></li></ul>
</div>
</div>
<p><a name="grammars"></a></p></div></div>
<div class="section">
<h2><a name="Grammars"></a>Grammars</h2>
<p>In this tutorial, we are writing a grammar that allow to parse a simple mathematical expression like this :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
sin( x ) * (1 + var_12)
</pre></div></div>
<p>The formal grammar definition looks like this, and we intend to write it in pure Java as close as possible to the original :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
[01] LBRACKET       ::= '('
[02] RBRACKET       ::= ')'
[03] FUNCTION       ::= 'sin' | 'cos' | 'exp' | 'ln' | 'sqrt'
[04] ADDITIVE       ::= '+' | '-'
[05] MULTIPLICATIVE ::= '*' | '/'
[06] UNDERSCORE     ::= '_'
[07] DIGIT          ::= [0-9]
[08] NUMBER         ::= DIGIT+
[09] UPPERCASE      ::= [A-Z]
[10] LOWERCASE      ::= [a-z]
[11] VARIABLE       ::= (LOWERCASE | UPPERCASE) (LOWERCASE | UPPERCASE | DIGIT | UNDERSCORE)*

[12] Expression     ::= Sum
[13] Value          ::= NUMBER | VARIABLE
[14] Argument       ::= FUNCTION Argument | Value | '(' Expression ')'
[15] Factor         ::= Argument ('^' SignedFactor)?
[16] Product        ::= Factor (MULTIPLICATIVE SignedFactor)*
[17] SignedTerm     ::= ADDITIVE? Product
[18] SignedFactor   ::= ADDITIVE? Factor
[19] Sum            ::= SignedTerm (ADDITIVE Product)*
</pre></div></div>
<p>Next, we will use our grammar for parsing an expression to our target object tree that can evaluate it.</p>
<p><a name="skeleton"></a></p>
<div class="section">
<h3><a name="The_grammar_skeleton"></a>The grammar skeleton</h3>
<p>Let&#x2019;s start with the skeleton of our class. As mentioned earlier, a grammar in Alternet Parsing MUST BE an <tt>interface</tt> ; and it has to extend the <a href="apidocs/ml/alternet/parser/Grammar.html"><tt>Grammar</tt></a> interface :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">package org.example.grammar;

import static ml.alternet.parser.Grammar.*;

public interface Calc extends Grammar {

    // Rules and Tokens will be defined here

    Calc $ = $(); // it MUST BE the last field of the grammar

}
</pre></div></div>
<p>The static import contains all the material useful for building your grammar. If you use an IDE you will have it available with autocompletion.</p>
<p>As a requirement, the last field of your grammar (actually the only one so far : <tt>$</tt>) <b>must</b> hold an instance of your grammar (generated by <a href="apidocs/ml/alternet/parser/Grammar.html#Z:Z:D--"><tt>$()</tt></a>), which will allow to parse the input text (we will talk later about that).</p>

<div class="alert alert-warning" role="alert">

<ul>

<li>The Grammar field will serve to parse the input</li>

<li>All the Rules and Tokens MUST BE declared BEFORE the Grammar field.</li>
</ul>
</div>
<p><a name="tokens"></a></p></div>
<div class="section">
<h3><a name="Tokens"></a>Tokens</h3>
<p>First, we just need to enumerate the tokens that are part of the grammar. A <a href="apidocs/ml/alternet/parser/Grammar.Token.html"><tt>Token</tt></a> is just a character, or a sequence of characters, that are (the more often) terminal values of the grammar, and to which we give a name. Therefore, if you look at the mathematical expression, we can identify the left bracket as being the character &#x2018;<tt>(</tt>&#x2019; ; in our grammar, we simply add a new field for the left bracket, and a second one for the right bracket :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //    LBRACKET   ::=  '('
    Token LBRACKET = is(  '('  ); // this is how we turn that definition to the Java syntax
    //    RBRACKET   ::=  ')'
    Token RBRACKET = is(  ')'  );
</pre></div></div>
<p>You may read it as you write it : the token <tt>LBRACKET</tt> is the character &#x2018;<tt>(</tt>&#x2019;.</p>
<p>Since you are defining those fields in a Java <tt>interface</tt>, no need to specify <tt>public static final</tt> on them.</p>

<div class="alert alert-info" role="alert">

<p>Supplementary Unicode characters (whose code points are greater than U+FFFF) can also be defined as tokens :</p>

<div class="source">
<div class="source">
<pre class="prettyprint linenums">
   Token UNICODE_CHAR_CODE = is(0x1F60E);
   Token UNICODE_CHAR = is(&quot;&#x1f60e;&quot;.codePointAt(0));

   Token UNICODE_STRING = isOneOf(&quot;&#x1f60e;&#x2615;&#x1f340;&quot;);
</pre></div></div>
</div>
<p>A token can be defined with one of the numerous static methods of <a href="apidocs/ml/alternet/parser/Grammar.html"><tt>Grammar</tt></a>.</p>
<p>Similarly, we could define a token for the <tt>sin</tt> function that appears in the mathematical expression :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
    Token SIN_FUNCTION = is(&quot;sin&quot;);
</pre></div></div>
<p><a name="enumTokens"></a></p>
<div class="section">
<h4><a name="Enum_tokens"></a>Enum tokens</h4>
<p>We could enumerate the other functions that our parser have to support, but since we are writing our grammar in Java, we can do better. Instead, we are designing an enum class, and create a token based on its values :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // FUNCTION ::= 'sin' | 'cos' | 'exp' | 'ln' | 'sqrt'
    enum Function {
        sin, cos, exp, ln, sqrt;
    }
    Token FUNCTION = is(Function.class);
</pre></div></div>
<p>Again, you may read it as you write it : the token <tt>FUNCTION</tt> is given by the enum <tt>Function.class</tt>.</p>
<p>Sometimes, a token can&#x2019;t be written as an enum value, because Java names have naming constraints. This is the case in our grammar, we want to write an enum class for &#x201c;<tt>+</tt>&#x201d; and &#x201c;<tt>-</tt>&#x201d; but they are invalid Java names :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // ADDITIVE ::= '+' | '-'
    enum Additive {
        +, -; // &#x26d4; you can't write that in Java
    }
    Token ADDITIVE = is(Additive.class);
</pre></div></div>
<p>We have a tool for getting rid of that limitations. First, add the following import :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">import static ml.alternet.util.EnumUtil.replace;
</pre></div></div>
<p>&#x2026;and use it in the constructor like this in order to replace the token value by the one supplied :</p>

<div class="tabs">

<input class="tab1" id="tabAdditiveEnum" type="radio" name="enumTokens" checked="checked"><label for="tabAdditiveEnum">Additive</label></input>
<input class="tab2" id="tabMultiplicativeEnum" type="radio" name="enumTokens"><label for="tabMultiplicativeEnum">Multiplicative</label></input>


<div class="tab1">

<div>
<pre class="prettyprint linenums">
    // ADDITIVE ::= '+' | '-'
    enum Additive {
        PLUS(&quot;+&quot;), MINUS(&quot;-&quot;);
        Additive(String str) {
            replace(this, s -&gt; str);
        }
    }
    Token ADDITIVE = is(Additive.class);</pre></div>
</div>


<div class="tab2">
Repeat for the multiplicative token :

<div>
<pre class="prettyprint linenums">
    // MULTIPLICATIVE ::= '*' | '/'
    enum Multiplicative {
        MULT(&quot;*&quot;), DIV(&quot;/&quot;);
        Multiplicative(String str) {
            replace(this, s -&gt; str);
        }
    }
    Token MULTIPLICATIVE = is(Multiplicative.class);
</pre></div>
</div>

</div>
<p>The <tt>PLUS</tt> value will be replaced by the <tt>+</tt> value, and the <tt>MINUS</tt> value will be replaced by the <tt>-</tt> value. The idea is to have in enum types tokens that are exactly those expected in the input text. If the input to parse contains &#x201c;<tt>+</tt>&#x201d; the token value get will be <tt>Additive.PLUS</tt>.</p>
<p>Sometimes, the replacement is generic. Let&#x2019;s consider the XPath grammar : if you look at the <a class="externalLink" href="https://www.w3.org/TR/xpath/#axes">XPath specification</a>, you will find 13 axis that contain a &#x201c;<tt>-</tt>&#x201d; in their names, which is an invalid character in Java names. Instead, we will write the values with &#x201c;<tt>_</tt>&#x201d; and replace them in the constructor like this :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // # From the XPath specification
    // [6] AxisName   ::=   'ancestor' | 'ancestor-or-self' | 'attribute'
    //                    | 'child' | 'descendant' | 'descendant-or-self'
    //                    | 'following' | 'following-sibling' | 'namespace'
    //                    | 'parent' | 'preceding' | 'preceding-sibling' | 'self'
    public enum Axis {
            ancestor, ancestor_or_self, attribute,
            child, descendant, descendant_or_self,
            following, following_sibling, namespace,
            parent, preceding, preceding_sibling, self;
        Axis() {
            // replace the &quot;_&quot; in the name by a &quot;-&quot;
            replace(this, s -&gt; s.replace('_', '-'));
        }
    }
    Token AxisName = is(Axis.class);
</pre></div></div>
<p>When parsing, the longest value if available will be read from the input. That is to say if the input contains &#x201c;<tt>ancestor-or-self</tt>&#x201d; the token value get will be <tt>Axis.ancestor_or_self</tt> and not jut <tt>Axis.ancestor</tt>. It means that the order of the enum values doesn&#x2019;t matter in the enum class. Internally, the tokenizer is smart enough to group commons characters together to avoid testing the same sequence several times.</p>
<p><a name="fragments"></a></p></div>
<div class="section">
<h4><a name="Fragment_tokens_and_composed_tokens"></a>Fragment tokens and composed tokens</h4>
<p>Let&#x2019;s go back to our grammar.</p>
<p>The production of variable names (<tt>var_12</tt> in our example) is made of &#x201c;<tt>_</tt>&#x201d;, digits, and lowercase or uppercase characters. We can define the expected tokens like this :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //    UNDERSCORE  ::= '_';
    @Fragment
    Token UNDERSCORE = is('_');

    //    UPPERCASE     ::= [A-Z]
    @Fragment
    Token UPPERCASE = range('A', 'Z');

    //    LOWERCASE     ::= [a-z]
    @Fragment
    Token LOWERCASE = range('a', 'z');

    //    DIGIT     ::= [0-9]
    @Fragment
    Token DIGIT = range('0', '9')
            .asNumber();

    //    VARIABLE ::= (LOWERCASE  |  UPPERCASE) (LOWERCASE | UPPERCASE | DIGIT | UNDERSCORE)*
    Token VARIABLE = ( (LOWERCASE).or(UPPERCASE) ).seq(
            ( (LOWERCASE).or(UPPERCASE).or(DIGIT).or(UNDERSCORE) ).zeroOrMore() )
            .asToken();
</pre></div></div>

<ul>
  
<li>The production of <tt>Token DIGIT</tt> ends with <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#asNumber--"><tt>.asNumber();</tt></a>, that is a convenient method to get number values instead of raw strings during parsing.</li>
  
<li>The production of <tt>Token VARIABLE</tt> ends with <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#asToken--"><tt>.asToken();</tt></a>. In fact, we have written our first <tt>Rule</tt> but we want to turn the entire rule in a simple token. We will examine rules in detail in the next section.</li>
  
<li>In fact, the <tt>Token VARIABLE</tt> is made of smaller tokens, that are marked as <tt>@Fragment</tt>.</li>
</ul>
<p><a href="apidocs/ml/alternet/parser/Grammar.Fragment.html"><tt>@Fragment</tt></a> ? A token is not necessary the smallest component of a grammar, but rather the smallest <i>useful</i> component of a grammar. In fact, we have convenient <tt>@Fragment</tt>s tokens that are defined here because they may be used elsewhere. But the real useful part is to have a <tt>VARIABLE</tt> produced by the parser, we don&#x2019;t care that that variable name is made of a mix of uppercase, lowercase, digits, and underscore characters (our grammar ensure that it will be the case), we just want a variable name. If we omit the <tt>@Fragment</tt> annotation, each individual token will be produced by the parser and may mask the production of a <tt>VARIABLE</tt> token. However, when entering a token composed of other tokens, the components will be considered as fragments.</p>
<p>We can reuse the previously fragments defined elsewhere by using <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#asToken--"><tt>.asToken()</tt></a> if we want a string token, or <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#asNumber--"><tt>.asNumber()</tt></a> if we want a number. A token annotated as fragment should be discarded, except if it is used in a rule exposed itself as a token with <tt>.asToken()</tt> or <tt>.asNumber()</tt> : such rule will aggregate the fragment tokens.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // NUMBER  ::= DIGIT+
    Token NUMBER = DIGIT.oneOrMore()
            .asNumber();
</pre></div></div>
<p>All non-fragments tokens can be get in the so-called &#x201c;tokenizer rule&#x201d; by the method <a href="apidocs/ml/alternet/parser/Grammar.html#tokenizer--"><tt>Calc.$.tokenizer()</tt></a> (more on this later).</p>
<p><a name="charTokens"></a></p></div>
<div class="section">
<h4><a name="Char_tokens"></a>Char tokens</h4>
<p>As an alternative, you can combine character tokens (<a href="apidocs/ml/alternet/parser/Grammar.CharToken.html"><tt>CharToken</tt></a>) directly :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //    VARIABLE ::= (LOWERCASE | UPPERCASE) (LOWERCASE | UPPERCASE | DIGIT | UNDERSCORE)*
    Token VARIABLE = range('a', 'z').union('A', 'Z').seq(
            range('a', 'z').union('A', 'Z').union(DIGIT).union('_').zeroOrMore() )
            .asToken();
</pre></div></div>
<p><a href="apidocs/ml/alternet/parser/Grammar.CharToken.html"><tt>CharToken</tt></a> contains all the material to define and combine by inclusion <tt>union()</tt> or exclusion <tt>except()</tt> other ranges of characters.</p>
<p><a name="rules"></a></p></div></div>
<div class="section">
<h3><a name="Rules"></a>Rules</h3>
<p>Now that we are able to split our input into tokens defined in our grammar, we can specify the <a href="apidocs/ml/alternet/parser/Grammar.Rule.html"><tt>Rule</tt>s</a> that tell how the input is structured.</p>
<p>A rule can be made of other rules and tokens. They are wired together by a connector that can be the alternative connector (&#x201c;|&#x201d; character in most formal grammar languages) or the sequential connector (a space in most grammars). In java, we have counterparts methods (<a href="apidocs/ml/alternet/parser/Grammar.Rule.html#or-ml.alternet.parser.Grammar.Rule...-"><tt>or()</tt></a> and <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#seq-ml.alternet.parser.Grammar.Rule...-"><tt>seq()</tt></a>) for that.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //   Value ::=  NUMBER  |  VARIABLE
    Rule Value   = (NUMBER).or(VARIABLE);
</pre></div></div>
<p>We can combine several tokens ; say that we defined the tokens T1, T2, etc :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // MyRule ::=  T1  |  T2  |  T3  |  T4  |  T5
    Rule MyRule = (T1).or(T2).or(T3).or(T4).or(T5);
</pre></div></div>
<p>or more consicely :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //   MyRule ::= T1 |  T2 | T3 | T4 | T5
    Rule MyRule   = T1.or(T2,  T3,  T4,  T5);
</pre></div></div>
<p>The <tt>or()</tt> method is lazy : while parsing, the first rule that will match the input will fulfill the production rule.</p>

<div class="alert alert-error" role="alert">
As a consequence, grammars expressed with :

<div class="source">
<div class="source">
<pre class="prettyprint">
[1]     Items    ::=      ITEM | Items ',' ITEM
</pre></div></div>
must be rewrite to :

<div class="source">
<div class="source">
<pre class="prettyprint">
[1]     Items    ::=      ITEM ( ',' ITEM )*
</pre></div></div>
</div>
<p>Similarly, for a sequence we write :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //   MyRule ::=  T1      T2      T3      T4      T5
    Rule MyRule   = (T1).seq(T2).seq(T3).seq(T4).seq(T5);
</pre></div></div>
<p>or more consicely :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //   MyRule ::= T1     T2  T3  T4  T5
    Rule MyRule   = T1.seq(T2, T3, T4, T5);
</pre></div></div>
<p>The thing to notice when writing grammars in <i>Alternet Parsing</i>, is that you write rules in the same order where they appear in the formal grammar language.</p>
<p><a name="repeating"></a></p>
<div class="section">
<h4><a name="Repeating"></a>Repeating</h4>
<p>Rule parts can be combined together, and combined with operators such as * ? or +, that have their counterpart Java methods <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#zeroOrMore--"><tt>zeroOrMore()</tt></a>, <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#optional--"><tt>optional()</tt></a>, <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#oneOrMore--"><tt>oneOrMore()</tt></a>:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // RuleA ::= T1 *
    Rule RuleA = T1.zeroOrMore();
    // RuleB ::= T1 ?
    Rule RuleB = T1.optional();
    // RuleC ::= T1 +
    Rule RuleC = T1.oneOrMore();

    // RuleD ::= T1 ? | T2 +
    Rule RuleD = T1.optional().or( T2.oneOrMore() );
    // RuleE ::= (T1 ? | T2) +
    Rule RuleE = T1.optional().or(T2).oneOrMore();
</pre></div></div>
<p>Notice how we wrote the 2 last rules. Remember that we are expressing rules in the Java language, and that the &#x201c;<tt>.</tt>&#x201d; (dot) operator in Java applies a method on the previously given object. Therefore, when we write <tt>.or( T2.oneOrMore() )</tt> the <tt>oneOrMore()</tt> method applies on <tt>T2</tt> only, and when we write <tt>.or(T2).oneOrMore()</tt> this time the <tt>oneOrMore()</tt> method applies to the result of the <tt>or()</tt> connector to which <tt>T2</tt> was connected, that is to say an optional <tt>T1</tt>.</p>
<p>Additional operators are available : <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#atLeast-int-"><tt>atLeast()</tt></a>, <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#atMost-int-"><tt>atMost()</tt></a> and <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#bounds-int-int-"><tt>bounds()</tt></a> :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // RuleX ::= T1{3,}
    Rule RuleX = T1.atLeast(3);
    // RuleY ::= T1{,12}
    Rule RuleY = T1.atMost(12);
    // RuleZ ::= T1{3,12}
    Rule RuleZ = T1.bounds(3, 12);
</pre></div></div>
<p>Now we are able to write such rules, and when necessary to turn rules in tokens :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //    VARIABLE ::= (LOWERCASE | UPPERCASE) (LOWERCASE | UPPERCASE | DIGIT | UNDERSCORE)*
    Token VARIABLE = LOWERCASE.or(UPPERCASE).seq(
            LOWERCASE.or(UPPERCASE, DIGIT, UNDERSCORE).zeroOrMore() )
            .asToken();
</pre></div></div>
<p><a name="self"></a></p></div>
<div class="section">
<h4><a name="Self_rule_and_deferred_rules"></a>Self rule and deferred rules</h4>
<p>Let&#x2019;s go back to our grammar.</p>
<p>We have all the material to write rules like this :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Expression ::= Sum
    Rule Expression = is(Sum); // &#x26d4; you can't write that in Java because Sum is not yet defined

    //   Argument ::= FUNCTION     Argument  |   Value   |   LBRACKET      Expression  RBRACKET
    Rule Argument =   FUNCTION.seq(Argument).or( Value ).or( LBRACKET.seq( Expression, RBRACKET ) );
                                 // &#x26d4; you can't write that either
</pre></div></div>
<p>Unfortunately, this writing <i>fails</i>, because we are in a Java program, and we can&#x2019;t define a field (actually <tt>Argument</tt>) by being a composition of itself. You can&#x2019;t either define a field (actually <tt>Expression</tt>) being composed of other rules that are not yet defined. Actually <tt>Sum</tt> has not yet been defined. We could define it before, but a <tt>Sum</tt> will be made sooner or later of <tt>Expression</tt>s (indirectly).</p>

<div class="alert alert-info" role="alert">
It's not rare to see grammars defining rules that are referring each others or rules that are referring themselves.
</div>
<p>Note that the following fix also <i>fail</i> because the value of the <tt>Sum</tt> field, although correctly referred is not yet assigned and a <tt>null</tt> value would be passed :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Expression ::=      Sum
    Rule Expression = is(Calc.Sum); // &#x26d4; in fact we have null
</pre></div></div>
<p>To fix this, we introduce <tt>$(&quot;Sum&quot;)</tt> and <tt>$(&quot;Argument&quot;)</tt> that are placeholders for rules not yet defined or defined later in our Java program :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Expression ::=    Sum
    Rule Expression = $(&quot;Sum&quot;);
    //   Argument ::= FUNCTION        Argument  |     Value   |   LBRACKET      Expression  RBRACKET
    Rule Argument =   FUNCTION.seq($(&quot;Argument&quot;)).or( Value ).or( LBRACKET.seq( Expression, RBRACKET ) );
</pre></div></div>
<p>The built-in token <a href="apidocs/ml/alternet/parser/Grammar.html#Z:Z:Dself"><tt>$self</tt></a> can be used instead of <tt>$(&quot;Argument&quot;)</tt> within the definition of the field <tt>Argument</tt> :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Expression ::=    Sum
    Rule Expression = $(&quot;Sum&quot;);
    //   Argument ::= FUNCTION    Argument  |   Value   |   LBRACKET      Expression  RBRACKET
    Rule Argument =   FUNCTION.seq( $self ).or( Value ).or( LBRACKET.seq( Expression, RBRACKET ) );
</pre></div></div>
<p><tt>$(&quot;Sum&quot;)</tt> stands for a reference to the following rule declaration :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //   Sum ::= SignedTerm    (ADDITIVE     Product)*
    Rule Sum =   SignedTerm.seq(ADDITIVE.seq(Product).zeroOrMore());
</pre></div></div>
<p>(at this time we assume that <tt>SignedTerm</tt> and <tt>Product</tt> have been too already defined, either directly or with a proxy, you know the recipe).</p>
<p><a name="proxy"></a></p></div>
<div class="section">
<h4><a name="Proxy_rules"></a>Proxy rules</h4>
<p>If you are in trouble by writing <tt>$(&quot;Sum&quot;)</tt> (which reduce the ease of reading), you can instead define it previously by being a <a href="apidocs/ml/alternet/parser/Grammar.Proxy.html"><tt>Proxy</tt></a> rule:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Proxy Sum = $(); // we expect a definition later
    // Expression ::=    Sum
    Rule Expression = is(Sum); // but we can use it here
    //   Argument ::= FUNCTION    Argument  |   Value   |   LBRACKET      Expression  RBRACKET
    Rule Argument =   FUNCTION.seq( $self ).or( Value ).or( LBRACKET.seq( Expression, RBRACKET ) );
</pre></div></div>
<p>&#x2026;and later in the grammar, you supply its definition when appropriate. You can write it in 3 different flavors, plus the possibility to write it inline :</p>

<div class="tabs">

<input class="tab1" id="tabStaticBlock" type="radio" name="proxy" checked="checked"><label for="tabStaticBlock">as static block</label></input>
<input class="tab2" id="tabStaticMethod" type="radio" name="proxy"><label for="tabStaticMethod">as static method</label></input>
<input class="tab3" id="tabAsProperty" type="radio" name="proxy"><label for="tabAsProperty">as $property</label></input>
<input class="tab4" id="tabInline" type="radio" name="proxy"><label for="tabInline">inline</label></input>


<div class="tab1">

<ul>
<li>The former writing consist on mimicking a static block :</li></ul>

<div>
<pre class="prettyprint linenums">
    boolean b1 = 
    // Sum ::= SignedTerm (ADDITIVE Product)*
    Sum.is(
        SignedTerm.seq(ADDITIVE.seq(Product).zeroOrMore())
    );</pre></div>

<p>Why do we have a boolean ? In fact we just want to set a value to <tt>Sum</tt>, but since it has
already been defined before, this writing is just a convenient way with Java to supply its value ; since an interface can't have static blocks, we are creating a dummy field <tt>b1</tt>.</p>
</div>


<div class="tab2">

<ul>
<li>The second writing consist on declaring a <tt>static</tt> method that has the same name of the field, actually <tt>Sum()</tt>, that return the actual rule.</li></ul>

<div>
<pre class="prettyprint linenums">
    // Sum ::= SignedTerm (ADDITIVE Product)*
    static Rule Sum() {
        return SignedTerm.seq(ADDITIVE.seq(Product).zeroOrMore());
    }</pre></div>
</div>


<div class="tab3">

<ul>
<li>The latter writing consist on declaring a property that has the same name of the field prepend with $, actually <tt>$Sum</tt>, this property being a <b>supplier</b> of the expected rule.</li></ul>

<div>
<pre class="prettyprint linenums">
    // Sum ::= SignedTerm (ADDITIVE Product)*
    Supplier&lt;Rule&gt; $Sum = () -&gt; SignedTerm.seq(ADDITIVE.seq(Product).zeroOrMore());</pre></div>
</div>


<div class="tab4">

<ul>
<li>Alternatively, you can also supply the definition <i>inline</i>, at the place the rule field is declared. In that case, each field not yet defined in the grammar has to be taken from the grammar class ; in our example the fields <tt>SignedTerm</tt> and <tt>Product</tt> have not yet been defined, and we must refer them as class members : <tt>Calc.SignedTerm</tt> and <tt>Calc.Product</tt>.</li>

<li>Unlike previously, we don't get <tt>null</tt> values because the supplier is a deferred method that will set the rule definition after all fields initialization :</li></ul>

<div>
<pre class="prettyprint linenums">
    // Sum ::= SignedTerm (ADDITIVE Product)*
    Rule Sum = $(() -&gt; 
               Calc.SignedTerm.seq(ADDITIVE.seq(Calc.Product).zeroOrMore())
    );
    // Expression ::=    Sum
    Rule Expression = is(Sum);
    //   Argument ::= FUNCTION    Argument  |   Value   |   LBRACKET      Expression  RBRACKET
    Rule Argument =   FUNCTION.seq( $self ).or( Value ).or( LBRACKET.seq( Expression, RBRACKET ) );
</pre></div>

<p>The advantage of this writing is that the rule is defined in place, but at the cost of few extra syntax.</p>
</div>

</div>
<hr />
<p>Choose your style of writing : <tt>$()</tt> with its inline or deferred assignment is interchangeable with <tt>$(&quot;foo&quot;)</tt> with a normal definition.</p>
<p>Now you should be able to write yourself the remaining rules. The complete code of <tt>Calc</tt> grammar is available on Github. <a class="externalLink" href="https://github.com/alternet/alternet.ml/blob/master/parsing/src/test/java/ml/alternet/parser/step1/Calc.java"><tt>Calc</tt></a></p>
<p><a name="directRef"></a></p></div>
<div class="section">
<h4><a name="Direct_reference"></a>Direct reference</h4>
<p>Now that we are able to write</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Expression ::=    Sum
    Rule Expression = is(Sum);
</pre></div></div>
<p>you might wonder why we didn&#x2019;t write it like that :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // Expression ::=    Sum
    Rule Expression = Sum; // &#x26d4; you will have an error
</pre></div></div>
<p>The engine won&#x2019;t let you write that and reject such grammar. Rules must hold a specific value, not identical values because if one rule was annotated (read after), it would affect both fields. Therefore it is forbidden.</p>
<p><a name="whitespaces"></a></p></div>
<div class="section">
<h4><a name="Skipping_whitespaces_and_other_characters"></a>Skipping whitespaces and other characters</h4>
<p>In fact, we would like to parse inputs like this :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">sin (x) * ( 1 + var_12 )
</pre></div></div>
<p>So simple in Alternet Parsing ;) with <a href="apidocs/ml/alternet/parser/Grammar.Skip.html"><tt>@Skip</tt></a></p>
<p>By default, whitespaces are left as-is, but if you want to ignore them (or any other characters), simply set this annotation to your grammar that refer to the token that contain the characters to skip (the referred token must be a <tt>@Fragment</tt>) :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">@Skip(token=&quot;WS&quot;) // the WS token is defined below
public interface Calc extends Grammar {

    // tokens and rules definition here

    @Fragment
    CharToken WS = isOneOf(&quot; \t\n\r&quot;); // the characters that we want to skip

    Calc $ = $();
}
</pre></div></div>
<p>You may want to define the skip token in a separate grammar :</p>

<div style="columns: 2">

<div>

<div>
<pre class="prettyprint">
@Skip(token=&quot;WS&quot;, grammar=WS.class)
public interface Calc extends Grammar {

    // tokens and rules definition here

    Calc $ = $();
}
</pre></div>
</div>

<div style="break-before: column">

<div>
<pre class="prettyprint">
public interface WS extends Grammar {

    @Fragment
    CharToken WS = isOneOf(&quot; \t\n\r&quot;);

    WS $ = $();
}
</pre></div>
</div>
</div>
<p>The <tt>@Skip</tt> annotation can be set :</p>

<ul>
  
<li>on a grammar, which affect <b>all the named tokens</b> except the fields annotated with <tt>@Fragment</tt>,</li>
  
<li>on any token in order to overriding the grammar value.</li>
</ul>

<div class="source">
<div class="source"><pre class="prettyprint linenums">@Skip(token=&quot;WS&quot;)                           // applied to all non-@Fragment tokens
public interface Example extends Grammar {

    @Fragment
    CharToken WS = isOneOf(&quot; \t\n\r&quot;);      // not affected by itself !

    Token COMMA = is(',');                  // affected by the grammar definition

    @Fragment
    Token UNDERSCORE = is('_');             // not affected because it is a fragment

    @Fragment
    @Skip(token=&quot;WS&quot;)
    Token SHARP = is('#');                  // affected by its own definition

    @Skip(token=&quot;special&quot;, grammar=Special.class)
    Token ALPHABET = range('A', 'Z');       // overriding by another token of another grammar

    @Skip(token=&quot;$empty&quot;)
    Token DIGIT = range('0', '9')           // unset by overriding with $empty
            .asNumber();

    Example $ = $();
}
</pre></div></div>
<p>Above :</p>

<ul>
  
<li><tt>WS</tt> is a simple <tt>CharToken</tt>, but any arbitrary complex rule exposed as a token with <tt>.asToken()</tt> is acceptable too (as long as its subrules are not affected by the grammar annotation).</li>
  
<li><a href="apidocs/ml/alternet/parser/Grammar.html#Z:Z:Dany"><tt>$empty</tt></a> is a built-in token that matches NO character, used here to skip&#x2026; nothing, which disable skipping.</li>
</ul>
<p><a name="extending"></a></p></div>
<div class="section">
<h4><a name="Extending_grammars_and_overriding_rules"></a>Extending grammars and overriding rules</h4>
<p>It is possible to extend a grammar by adding new rules and tokens, but also to redefine some of them.</p>
<p>Imagine that we want to write a grammar that is almost the same as the <tt>Calc</tt> grammar, but with different rules :</p>

<ul>
  
<li>having more built-in functions</li>
  
<li>change the tokens <tt>*</tt> and <tt>/</tt> by <tt>&#xd7;</tt> and <tt>&#xf7;</tt></li>
  
<li>disallow lowercase characters in variable names</li>
  
<li>surround function arguments with parentheses</li>
</ul>
<p>Here are the changes :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
[03] FUNCTION       ::= 'sin' | 'cos' | 'exp' | 'ln' | 'sqrt' | 'asin' | 'acos'
[05] MULTIPLICATIVE ::= '&#xd7;' | '&#xf7;'
[11] VARIABLE       ::= UPPERCASE (UPPERCASE | DIGIT | UNDERSCORE)*

[14] Argument       ::= FUNCTION LBRACKET Argument RBRACKET | Value | LBRACKET Expression RBRACKET
</pre></div></div>
<p>To achieve this, the new grammar has just to extend the previous one :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public interface Math extends Calc { // &#x1f448; look here, we extend Calc

    // new rules and tokens here

    Math $ = $();

}
</pre></div></div>
<p>Then it has to contain its new definitions.</p>
<p>If the new field have the same name as an existing field in the other grammar, it is replacing it :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // MULTIPLICATIVE ::= '&#xd7;' | '&#xf7;'
    enum MathMultiplicative {
        MULT(&quot;&#xd7;&quot;), DIV(&quot;&#xf7;&quot;);
        MathMultiplicative(String str) {
            replace(MathMultiplicative.class, this, s -&gt; str);
        }
    }
    // same name than in Calc grammar -&gt; automatic replacement
    Token MULTIPLICATIVE = is(MathMultiplicative.class);

    //   Argument ::= FUNCTION      LBRACKET  Argument RBRACKET   |   Value
    //                                       |   LBRACKET      Expression  RBRACKET
    // same name than in Calc grammar -&gt; automatic replacement
    Rule Argument =   FUNCTION.seq( LBRACKET, $self,   RBRACKET ).or( Value )
                                            .or( LBRACKET.seq( Expression, RBRACKET ) );
</pre></div></div>
<p>If the new field has another name, we have to specify with the <a href="apidocs/ml/alternet/parser/Grammar.Replace.html"><tt>@Replace</tt></a> annotation which one it is replacing. Below, everywhere <tt>VARIABLE</tt> appears in the <tt>Calc</tt> grammar, it will be replaced by <tt>UPPERCASE_VARIABLE</tt> in the <tt>Math</tt> grammar (and of course stay unchanged in the <tt>Calc</tt> grammar) :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // VARIABLE ::= [A-Z] ([A-Z] | DIGIT | '_')*
    @Replace(field=&quot;VARIABLE&quot;) // because the field below has another name
    Token UPPERCASE_VARIABLE = UPPERCASE.seq(
            UPPERCASE.or(DIGIT, UNDERSCORE).zeroOrMore() )
            .asToken();
</pre></div></div>
<p>Sometimes, you have to extend several grammars that may have fields with the same name ; in this case, you also have to specify the appropriate grammar in the annotation :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // FUNCTION ::= 'sin' | 'cos' | 'exp' | 'ln' | 'sqrt' | 'asin' | 'acos'
    enum MathFunction {
        sin, cos, exp, ln, sqrt, asin, acos;
    }
    @Replace(grammar=Calc.class, field=&quot;FUNCTION&quot;)    // replace Calc.FUNCTION
    Token ADVANCED_FUNCTION = is(MathFunction.class);
</pre></div></div>
<p>A nice helper tool also allows to extend enums :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    // FUNCTION ::= 'sin' | 'cos' | 'exp' | 'ln' | 'sqrt' | 'asin' | 'acos'
    enum MathFunction {
        asin, acos;
        static {
            EnumUtil.extend(Calc.Function.class); // other values are imported
        }
    }
    @Replace(grammar=Calc.class, field=&quot;FUNCTION&quot;)    // replace Calc.FUNCTION
    Token ADVANCED_FUNCTION = is(MathFunction.class);
</pre></div></div>
<p>You don&#x2019;t need to rewrite the rules where those new definitions are used, they will be replaced in the new grammar. Of course, the original grammar will stay unchanged.</p>
<p>Here is a parsing example with each grammar :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Calc.$.parse(Scanner.of(&quot;sin( x ) * ( 1 + var_12 )&quot;), handler);
    Math.$.parse(Scanner.of(&quot;asin( X ) &#xd7; ( 1 + VAR_12 )&quot;), handler);
</pre></div></div>
<p>(more about parsing later)</p>
<p>Sometimes, you may tend to use tokens directly in rules without defining <b>named</b> tokens in the grammar. Using named tokens allow global replacements without needing to rewrite each rule that use them. In our grammar, since we have names for the parenthesis, it is very easy to design a new grammar that just change the parenthesis with, say, square brackets :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public interface CalcSquare extends Calc { // &#x1f448; look here, we extend Calc

    Token LBRACKET = is( '[' );
    Token RBRACKET = is( ']' );

    CalcSquare $ = $();

}
</pre></div></div>
<p>Substitutions will occur everywhere <tt>LBRACKET</tt> and <tt>RBRACKET</tt> are referred in the new grammar. Now we can parse <tt>sin[ x ] * [1 + var_12]</tt> with the <tt>ClacSquare</tt> grammar.</p>
<p>In the next section we will learn how to build a custom data model.</p>
<p><a name="customTypes"></a></p></div></div></div>
<div class="section">
<h2><a name="Grammar_with_custom_token_types"></a>Grammar with custom token types</h2>
<p>A <b>token value</b> represents the input characters that are parsed. We have seen before that a token value may have various types :</p>

<ul>
  
<li><b>a single character</b> : this is the default behaviour. E.g. <tt>&quot;(&quot;</tt></li>
  
<li><b>a string</b> : this is also the default behaviour when a sequence of characters is matched. E.g. <tt>&quot;var_12&quot;</tt></li>
  
<li><b>a number</b> : when the token is defined with <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#asNumber--"><tt>.asNumber()</tt></a>. E.g. <tt>123.45</tt> (it is also possible to specify the type of the number)</li>
  
<li><b>an enum value</b> : when the token is defined with an enum class. E.g. <tt>Axis.ancestor_or_self</tt></li>
</ul>
<p>It is also possible to specify in the grammar :</p>

<ul>
  
<li>characters that we want to skip. E.g. <tt>&quot;\\&quot;</tt> where the first <tt>\</tt> stand for an escape character and the second <tt>\</tt> for the data.</li>
  
<li>characters rendered as a custom object. E.g. our custom class <tt>Challenge</tt> defined here after.</li>
</ul>
<p>Let&#x2019;s show how.</p>
<p>In this example, we intend to parse the WWW-Authenticate header sent by an HTTP server in a response 401 : &#xab; Unauthorized &#xbb;, that indicates how the client can authenticate :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
# Challenge Basic
WWW-Authenticate: Basic realm=&quot;FooCorp&quot;
</pre></div></div>

<div class="source">
<div class="source">
<pre class="prettyprint">
# Challenge OAuth 2.0 apr&#xe8;s l'envoi d'un token expir&#xe9;
WWW-Authenticate: Bearer realm=&quot;FooCorp&quot;, error=invalid_token, error_description=&quot;The \&quot;access token\&quot; has expired&quot;
</pre></div></div>
<p>We will design our <tt>WAuth</tt> grammar and our custom result objects (for the part after &#x201c;WWW-Authenticate:&#x201d;), say the <tt>Challenge</tt> class for the global result and the <tt>Parameter</tt> class for each {name, value} pair.</p>
<p><a name="targetClasses"></a></p>
<div class="section">
<h3><a name="The_target_custom_classes"></a>The target custom classes</h3>
<p>Our custom classes, first, are very simple ; notice they are agnostic regarding our future grammar, they are just POJOs :</p>

<div style="columns: 2">

<div>

<div>
<pre class="prettyprint linenums">
public class Parameter {

    public String name;  // e.g. &quot;realm&quot;
    public String value; // e.g. &quot;FooCorp&quot;

    public Parameter(String name, String value) {
        this.name = name;
        this.value = value;
    }
}</pre></div>
</div>

<div style="break-before: column">

<div>
<pre class="prettyprint linenums">
public class Challenge {

    public String scheme; // e.g. &quot;Basic&quot;
    public List&lt;Parameter&gt; parameters;

    public Challenge(String scheme, List&lt;Parameter&gt; parameters) {
        this.scheme = scheme;
        this.parameters = parameters;
    }

}</pre></div>
</div>
</div></div>
<div class="section">
<h3><a name="The_WAuth_grammar"></a>The WAuth grammar</h3>
<p>Now, the grammar (using the &#x201c;Augmented BNF&#x201d; syntax, see &#xa7;2.1 in <a class="externalLink" href="https://www.ietf.org/rfc/rfc2616.txt">RFC-2616</a>) :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
# from RFC-2617 (HTTP Basic and Digest authentication)

challenge      = auth-scheme 1*SP 1#auth-param
auth-scheme    = token
auth-param     = token &quot;=&quot; ( token | quoted-string )

# from RFC-2616 (HTTP/1.1)

token          = 1*&lt;any CHAR except CTLs or separators&gt;
separators     = &quot;(&quot; | &quot;)&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;@&quot;
               | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &lt;&quot;&gt;
               | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;
               | &quot;{&quot; | &quot;}&quot; | SP | HT
quoted-string  = ( &lt;&quot;&gt; *(qdtext | quoted-pair ) &lt;&quot;&gt; )
qdtext         = &lt;any TEXT except &lt;&quot;&gt;&gt;
quoted-pair    = &quot;\&quot; CHAR
</pre></div></div>
<p><a name="drop"></a></p></div>
<div class="section">
<h3><a name="Dropping_tokens"></a>Dropping tokens</h3>
<p><tt>@Skip</tt> was used for ignoring some characters around a token, but sometimes you don&#x2019;t want the token value either ; for that purpose we will use <a href="apidocs/ml/alternet/parser/Grammar.Drop.html"><tt>@Drop</tt></a>. Having such annotated token means that we ensure that the input satisfies the grammar, but the value itself is useless, we just drop it.</p>
<p>Let&#x2019;s start the Java grammar :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public interface WAuth extends Grammar {

    @Fragment
    CharToken SP = is(' ');

    @Fragment
    Token SEPARATORS = isOneOf(&quot;()&lt;&gt;@,;:\\\&quot;/[]?={} \t&quot;); // '\', '&quot;' and TAB are escaped with \ in Java

    @Fragment
    Token CTRLS = range(0, 31).union(127); // octets 0 - 31 and DEL (127)

    @Fragment
    Token TOKEN_CHAR = isNot(SEPARATORS, CTRLS);

    @Skip(token=&quot;SP&quot;)
    Token TOKEN = TOKEN_CHAR.oneOrMore()   // we have a Token called TOKEN, why not...
            .asToken();

    @Fragment
    Token DOUBLE_QUOTE = is('&quot;');

    @Fragment
    @Drop
    Token BACKSLASH = is('\\');

    @Fragment
    Token QuotedPair = BACKSLASH.seq( $any ).asToken();

    // other tokens here

    WAuth $ = $();

}
</pre></div></div>
<p>We defined various tokens as ranges of characters, and tokens made of other tokens.</p>

<ul>
  
<li><a href="apidocs/ml/alternet/parser/Grammar.html#Z:Z:Dany"><tt>$any</tt></a> is a built-in token that matches any character.</li>
  
<li>Remember that as soon as you use modifiers such as <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#oneOrMore--"><tt>.oneOrMore()</tt></a> or combiners such as <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#seq-ml.alternet.parser.Grammar.Rule...-"><tt>.seq()</tt></a> you get a <tt>Rule</tt>, but you can turn it back to a <tt>Token</tt> with <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#asToken--"><tt>.asToken()</tt></a>.</li>
  
<li>The <tt>BACKSLASH</tt> token is dropped with <a href="apidocs/ml/alternet/parser/Grammar.Drop.html"><tt>@Drop</tt></a>. It means that the handler won&#x2019;t ever receive this token, but the grammar ensure that the following character is properly escaped, and that the relevant value received is properly stripped from the <tt>\</tt> character.</li>
</ul>
<p>Conversely, the <tt>DOUBLE_QUOTE</tt> token is not dropped at the token definition, because sometimes it stands for a delimiter (and in that case it has to be removed), and some other times it stands for itself (as <tt>&quot;</tt>). Therefore, we use <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#drop--"><tt>.drop()</tt></a> at the places we don&#x2019;t want to get <tt>&quot;</tt> as data :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    @Fragment
    Token QdText = isNot(DOUBLE_QUOTE);

    Token QuotedString = DOUBLE_QUOTE.drop().seq( // &quot; is a separator
            QuotedPair.or(QdText).zeroOrMore(),
            DOUBLE_QUOTE.drop())                  // &quot; is a separator too
        .asToken();

    @Skip(token=&quot;SP&quot;)
    Token ParameterValue = TOKEN.or(QuotedString).asToken();

    @Fragment
    Token EQUAL = is('=');
</pre></div></div>
<p><a name="mapping"></a></p></div>
<div class="section">
<h3><a name="Mapping_tokens"></a>Mapping tokens</h3>
<p>Instead of having <tt>String</tt>s or <tt>Numbers</tt>s, we expect having our types (yes, fields and types may have the same name) :</p>

<table border="0" class="table table-striped">
  <thead>
    
<tr class="a">
      
<th>Field name </th>
      
<th align="center">Type expected </th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td><tt>Parameter</tt> </td>
      
<td align="center"><tt>Parameter</tt> </td>
    </tr>
    
<tr class="a">
      
<td><tt>Parameters</tt> </td>
      
<td align="center"><tt>List&lt;Parameter&gt;</tt> </td>
    </tr>
    
<tr class="b">
      
<td><tt>Challenge</tt> </td>
      
<td align="center"><tt>Challenge</tt> </td>
    </tr>
  </tbody>
</table>
<p>We already used <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#asNumber--"><tt>.asNumber()</tt></a> for getting a number value and <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#asToken--"><tt>.asToken()</tt></a> for turning a rule to a token ; now we will use <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#asToken-java.util.function.Function-"><tt>.asToken(mapper)</tt></a> to turn the tokens of a rule to a custom object. Actually, we expect our <tt>Parameter</tt> object, and we have a special type for the counterpart definition : <a href="apidocs/ml/alternet/parser/Grammar.TypedToken.html"><tt>TypedToken&lt;T&gt;</tt></a>, in our case <a href="apidocs/ml/alternet/parser/Grammar.TypedToken.html"><tt>TypedToken&lt;Parameter&gt;</tt></a>. The mapper is just a function that takes as argument the <tt>List</tt> of tokens parsed by the rule and that returns a value that can be consumed by the enclosing rule.</p>
<p>Below, the rule will match <tt>aName = aValue</tt> in 3 tokens (<tt>aName</tt> then <tt>=</tt> then <tt>aValue</tt>), and we produce a <tt>Parameter</tt> object with the <b>first</b> and the <b>last</b> tokens because the <tt>=</tt> token is useless ; we could use <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#drop--"><tt>.drop()</tt></a> on it, but it wouldn&#x2019;t change anything because we are just ignoring it :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //                    Parameter ::= TOKEN     EQUAL  ParameterValue
    TypedToken&lt;Parameter&gt; Parameter =   TOKEN.seq(EQUAL, ParameterValue)  // e.g. &quot;aName = aValue&quot;
        .asToken(tokens -&gt;
            new Parameter(
                tokens.getFirst().getValue(), // TOKEN          e.g. &quot;aName&quot;
                tokens.getLast().getValue()   // ParameterValue e.g. &quot;aValue&quot;
        ));
</pre></div></div>
<p>Similarly, a list of parameters &#x2013;<tt>List&lt;Parameter&gt;</tt>&#x2013; can be produced easily, but since we don&#x2019;t know how many tokens will be available in that list, we are streaming the list of tokens. Since the <tt>Parameter<b>s</b></tt> rule is made of <tt>Parameter</tt> rules that create new instances of our <tt>Parameter</tt> POJO (yes, we have the same name for a rule and our POJO), we can safely cast the token value.</p>
<p>Below, we explore 3 other strategies for stripping out the comma from the token values :</p>

<div class="tabs">

<input class="tab1" id="tabFilterOut" type="radio" name="filtering" checked="checked"><label for="tabFilterOut">reject rule</label></input>
<input class="tab2" id="tabFilterWithDrop" type="radio" name="filtering" checked="checked"><label for="tabFilterWithDrop">using @Drop</label></input>
<input class="tab3" id="tabFilterIn" type="radio" name="filtering" checked="checked"><label for="tabFilterIn">accept token</label></input>


<div class="tab1">

<ul>
<li>For filtering out the unwanted tokens, we reject those that are different than <tt>COMMA</tt> : in that case, you can either compare the rule name or its <tt>.id()</tt></li>

<li>Don't compare Java references directly like this <tt>t.getRule() != COMMA</tt>, because Java references may change during the initialization phase of the grammars, typically on grammar extensions where rules are cloned from the original grammar to the extension grammar.</li></ul>

<div>
<pre class="prettyprint linenums">
    @Skip(token=&quot;SP&quot;)
    @Fragment
    Token COMMA = is(',');

    //                          Parameters ::= Parameter    (COMMA     Parameter?)*
    TypedToken&lt;List&lt;Parameter&gt;&gt; Parameters =   Parameter.seq(COMMA.seq(Parameter.optional()).zeroOrMore())
        .asToken(tokens -&gt;
            tokens.stream()
                .filter(t -&gt; t.getRule().id() != COMMA.id())   // reject &quot;,&quot;
                .map(t -&gt; (Parameter) t.getValue())            // extract the value as a Parameter object
                .collect(toList())                             // collect to List&lt;Parameter&gt;
        );</pre></div>
</div>


<div class="tab2">

<ul>
<li>A better solution would be to remove the filter and instead using <tt>@Drop</tt> :</li></ul>

<div>
<pre class="prettyprint linenums">
    @Skip(token=&quot;SP&quot;)
    @Fragment
    @Drop                                           // DROP !!!!
    Token COMMA = is(',');

    //                          Parameters ::= Parameter    (COMMA     Parameter?)*
    TypedToken&lt;List&lt;Parameter&gt;&gt; Parameters =   Parameter.seq(COMMA.seq(Parameter.optional()).zeroOrMore())
        .asToken(tokens -&gt;
            tokens.stream()
                .map(t -&gt; (Parameter) t.getValue()) // COMMA has been dropped
                .collect(toList())                  // collect to List&lt;Parameter&gt;
        );</pre></div>
</div>


<div class="tab3">

<ul>
<li>We could also simply accept token values that are <tt>Parameter</tt>s :</li></ul>

<div>
<pre class="prettyprint linenums">
    @Skip(token=&quot;SP&quot;)
    @Fragment
    Token COMMA = is(',');

    // Parameters ::= Parameter (COMMA Parameter?)*
    TypedToken&lt;List&lt;Parameter&gt;&gt; Parameters = WAuth.Parameters
        .asToken(tokens -&gt;
                tokens.stream()
                    .map(TokenValue::getValue)           // extract the value
                    .filter(p -&gt; p instanceof Parameter) // accept Parameter only
                    .map(p -&gt; (Parameter) p)
                    .collect(toList())                   // collect to List&lt;Parameter&gt;
        );</pre></div>
</div>

</div>
<hr />
<p>It&#x2019;s worth to mention that the tokens available in the list are instances of <a href="apidocs/ml/alternet/parser/EventsHandler.TokenValue.html"><tt>TokenValue&lt;V&gt;</tt></a> from which you can extract the rule/token that matched the input (<a href="apidocs/ml/alternet/parser/EventsHandler.RuleEvent.html#getRule--"><tt>.getRule()</tt></a>) and the actual value (<a href="apidocs/ml/alternet/parser/EventsHandler.TokenValue.html#getValue--"><tt>.getValue()</tt></a>). You can also retrieve the type of the value or set a new value.</p>
<p>Finally, the production of the <tt>Challenge</tt> is obvious, and it is marked as the main rule of our grammar (more about <tt>@MainRule</tt> on the next section) :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    //                    Challenge ::= TOKEN     Parameters
    @MainRule
    TypedToken&lt;Challenge&gt; Challenge =   TOKEN.seq(Parameters)
        .asToken(tokens -&gt; new Challenge(
            tokens.removeFirst().getValue(), // TOKEN,      as String
            tokens.removeFirst().getValue()) // Parameters, as List&lt;Parameter&gt;
        );
</pre></div></div>
<p>In a nutshell, the line #3 that defines the rule refers to other rules or tokens. The lines #4 to #7 that create an object refers to other objects previsouly created.</p>
<p>Now we can create a parser (outside of our grammar), to get optionally our challenge (it is optional because the parsing may fail) :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public class WAuthParser {

    public Challenge parse(String input) {
        Optional&lt;Challenge&gt; result = new NodeBuilder&lt;Challenge&gt;(WAuth.$).parse(input, true);
        return result.get(); // or throw an error
    }
}
</pre></div></div>
<p>We are using the <a href="apidocs/ml/alternet/parser/ast/NodeBuilder.html"><tt>NodeBuilder&lt;T&gt;</tt></a> class that can supply an instance of <tt>T</tt> if the parsing succeeds, actually our POJO <tt>Challenge</tt>. The boolean parameter indicates when set to <tt>true</tt> to consume all the characters from the input (it would be a failure if some characters remain at the end).</p>
<p><a name="augmented"></a></p></div>
<div class="section">
<h3><a name="Separating_the_raw_grammar_and_the_augmented_grammar"></a>Separating the raw grammar and the augmented grammar</h3>
<p>In the previous example, we made an augmented grammar as a whole (&#x201c;augmented&#x201d; means augmented with our custom classes). Imagine that somebody want to use our grammar but using its own classes ; he had to rewrite all the augmented rules + its own mappings, whereas it would be better if he had to write only its own mappings. We need a clean separation of the &#x201c;raw&#x201d; grammar that only deal with scalar and enum values, and the &#x201c;augmented&#x201d; grammar that uses our objects.</p>

<div class="alert alert-info" role="alert">
A &quot;raw grammar&quot; should supply only scalar values (Strings, Numbers, booleans) and enum values, but sometimes basic objects such as <tt>LocalDate</tt> or <tt>URI</tt> might be acceptable.
</div>
<p>First, let&#x2019;s clean the grammar in order to get back a raw grammar :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public interface WAuth extends Grammar {

    // all the tokens are defined here as shown previously...

    // Parameter ::= TOKEN     EQUAL  ParameterValue
    Rule Parameter = TOKEN.seq(EQUAL, ParameterValue);

    // Parameters ::= Parameter (COMMA Parameter?)*
    Rule Parameters = Parameter.seq(COMMA.seq(Parameter.optional()).zeroOrMore());

    // Challenge ::= TOKEN     Parameters
    @MainRule
    Rule Challenge = TOKEN.seq(Parameters);

    WAuth $ = $();

}
</pre></div></div>
<p>Now we can extend it in a second grammar with our own mappings :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public interface WAuthAugmented extends WAuth {

    //            augment Parameter from the rule of the raw grammar
    TypedToken&lt;Parameter&gt; Parameter = WAuth.Parameter
        .asToken(tokens -&gt;
            new Parameter(
                tokens.getFirst().getValue(), // TOKEN
                tokens.getLast().getValue()   // ParameterValue
        ));

    //                  augment Parameters from the rule of the raw grammar
    TypedToken&lt;List&lt;Parameter&gt;&gt; Parameters = WAuth.Parameters
        .asToken(tokens -&gt;
            tokens.stream()
                // drop &quot;,&quot;
                .filter(t -&gt; t.getRule().id() != COMMA.id())
                // extract the value as a Parameter
                .map(t -&gt; (Parameter) t.getValue())
                .collect(toList())
        );

    @MainRule
    //            augment Challenge from the rule of the raw grammar
    TypedToken&lt;Challenge&gt; Challenge = WAuth.Challenge
        .asToken(tokens -&gt; new Challenge(
            tokens.removeFirst().getValue(),
            tokens.removeFirst().getValue())
        );

    WAuthAugmented $ = $();

}
</pre></div></div>
<p>That way your users may use either the raw grammar, the augmented grammar with your classes, or their own augmented grammar with their own classes.</p>
<p>It is certainly a good practice to follow this pattern to make your grammar really reusable.</p>
<p><a name="parsing"></a></p></div></div>
<div class="section">
<h2><a name="Parsing"></a>Parsing</h2>
<p>Now that your grammar is well designed, you are able to parse your data and get custom objects.</p>
<p><a name="standalone"></a></p>
<div class="section">
<h3><a name="Parsing_a_standalone_grammar"></a>Parsing a standalone grammar</h3>
<p>For standalone grammars (grammars that produce typed tokens like our <tt>WAuthAugmented</tt> grammar), getting our custom object <tt>Challenge</tt> is straigthforward :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    String input = ...
    NodeBuilder&lt;Challenge&gt; parser = new NodeBuilder&lt;&gt;(WAuthAugmented.$);
    Optional&lt;Challenge&gt; challenge = parser.parse(input, true);
</pre></div></div>
<p>We get an optional instance because the input might not be parsable with that grammar.</p>
<p><a name="input"></a></p></div>
<div class="section">
<h3><a name="Parsing_an_input"></a>Parsing an input</h3>
<p>An input can be parsed :</p>

<ul>
  
<li>on a special rule that stands for the main rule (this is the more useful case)</li>
  
<li>on any of the token rules</li>
  
<li>on a given rule</li>
</ul>
<p>We have a grammar interface, <tt>Calc</tt>, and a field which is an instance of that grammar, <tt>Calc.$</tt>. From that instance, we can parse with <a href="apidocs/index.html?ml/alternet/parser/Grammar.Rule.html"><tt>Calc.$.parse()</tt></a> an input on a given rule, actually the <tt>Calc.Expression</tt> rule :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Handler handler = ...;
    String input = &quot;sin(x)*(1+var_12)&quot;;
    Calc.$.parse(
        Scanner.of(input),  // scan a String or a character stream
        handler,            // more about handlers later
        Calc.Expression,    // main rule in our grammar
        true);              // true to expect consume all the input
</pre></div></div>
<p>The <a href="apidocs/ml/alternet/parser/Handler.html">Handler</a> is the component that accept low-level parsing events (more about that on see next section). We will see that out-of-the-box sophisticated handler implementations are available.</p>
<p><a name="mainRule"></a></p>
<div class="section">
<h4><a name="The_main_rule"></a>The &#x201c;main&#x201d; rule</h4>
<p>If we consider that the field <tt>Expression</tt> is the <a href="apidocs/ml/alternet/parser/Grammar.MainRule.html">main rule</a> in our grammar, we can annotate it like this :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    @MainRule
    Rule Expression = SignedTerm.seq(SumOp);
</pre></div></div>
<p>If the <tt>parse()</tt> method is invoked without specifying any rule, that <b>main rule</b> will be used :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Handler handler = ...;
    String input = &quot;sin(x)*(1+var_12)&quot;;
    Calc.$.parse(Scanner.of(input), handler, true);
</pre></div></div>
<p><a name="tokenizer"></a></p></div>
<div class="section">
<h4><a name="The_tokenizer_rule"></a>The &#x201c;tokenizer&#x201d; rule</h4>
<p>A special rule is available in every grammar, it is the rule that takes all the tokens that are not fragment :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Handler handler = ...;
    String input = &quot;sin(x)*(1+var_12)&quot;;
    Calc.$.parse(Scanner.of(input), handler, Calc.tokenizer());
</pre></div></div>
<p>The tokenizer will match tokens regardlesss the structure, therefore inputs badly structured can be parsed, but you will be sure that the input is made of valid tokens.</p>
<p><a name="remainder"></a></p></div>
<div class="section">
<h4><a name="The_remainder"></a>The remainder</h4>
<p>Sometimes, you want to parse your data until no more matching is possible :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Handler handler = ...;
    String input = &quot;sin(x)*(1+var_12) is an expression&quot;;
    Scanner scanner = Scanner.of(input);
    Calc.$.parse(
        scanner,
        handler,
        false);  // false to stop parsing when nothing matches any longer
</pre></div></div>
<p>Then, the <a class="externalLink" href="http://alternet.ml/alternet-libs/scanner/apidocs/ml/alternet/scan/Scanner.html"><tt>scanner</tt></a> instance contains the remainder, ready for further processing with whatever ; you can also extract the remainder as a character <tt>Reader</tt> or a <tt>String</tt> (in the example above, the remainder characters are &#x201c;is an expression&#x201d;).</p>
<p><a name="handlers"></a></p></div></div>
<div class="section">
<h3><a name="Handlers"></a>Handlers</h3>
<p>Alternet Parsing comes with out-of-the-box <a href="apidocs/ml/alternet/parser/Handler.html"><tt>Handler</tt>s</a> that can receive the result of the parsing, that will be handy for processing that result :</p>

<ul>
  
<li><a href="apidocs/ml/alternet/parser/handlers/TreeHandler.html"><tt>TreeHandler</tt></a> : low-level API</li>
  
<li><a href="apidocs/ml/alternet/parser/ast/NodeBuilder.html"><tt>NodeBuilder</tt></a> : high-level API for building an AST made of homogeneous nodes.</li>
  
<li><a href="apidocs/ml/alternet/parser/ast/ValueBuilder.html"><tt>ValueBuilder</tt></a> : high-level API for building an heterogeneous AST.</li>
</ul>
<p>The <a href="apidocs/ml/alternet/parser/ast/package-summary.html">AST package</a> contains helper classes to build an Abstract Syntax Tree (<b>AST</b>) while parsing.</p>
<p><a name="dataModel"></a></p></div>
<div class="section">
<h3><a name="Target_data_model"></a>Target data model</h3>
<p>We have seen <a href="#customTypes">previously</a> that we are already able to produce custom types. Sometimes, we need more contextual data to be able to produce typed data ; typically, if you intend to build an homogeneous AST, you are in the right place.</p>
<p>Let&#x2019;s go back to our <tt>Calc</tt> grammar. We intend to compute expressions, and therefore build a target data model with the help of the <a href="apidocs/ml/alternet/parser/ast/Expression.html"><tt>Expression&lt;T,C&gt;</tt></a> class (of course you can use your own class instead) :</p>

<ul>
  
<li>where <tt>T</tt> is the type of the result of the computation, in our case it will be a <tt>Number</tt></li>
  
<li>and <tt>C</tt> the context of the evaluation ; according to the grammar, it may hold all the necessary for computing an expression, for example supply built-in and custom functions, namespace mappers, bound variables to their name, etc. In our example we just need to resolve variable names, and the context will be as simple as a <tt>Map&lt;String,Number&gt;</tt>.</li>
</ul>

<div class="source">
<div class="source"><pre class="prettyprint linenums">/**
 * The user data model is a tree of expressions.
 */
public interface NumericExpression extends Expression&lt;Number, Map&lt;String,Number&gt;&gt; { }
</pre></div></div>
<p>From this base, we are defining every kind of <tt>NumericExpression</tt> expected :</p>

<div class="alert alert-info" role="alert">
Notice that those classes are agnostic regarding <b>Alternet Parsing</b>, they are just user classes that doesn't require to extend or to implement anything related to <b>Alternet Parsing</b>
</div>

<div class="tabs">

<input class="tab1" id="tabConstant" type="radio" name="dataModel" checked="checked"><label for="tabConstant">Constant</label></input>
<input class="tab2" id="tabVariable" type="radio" name="dataModel"><label for="tabVariable">Variable</label></input>
<input class="tab3" id="tabExponent" type="radio" name="dataModel"><label for="tabExponent">Exponent</label></input>
<input class="tab4" id="tabFunction" type="radio" name="dataModel"><label for="tabFunction">Function</label></input>
<input class="tab5" id="tabTerm" type="radio" name="dataModel"><label for="tabTerm">Term</label></input>
<input class="tab6" id="tabSum" type="radio" name="dataModel"><label for="tabSum">Sum</label></input>
<input class="tab7" id="tabProduct" type="radio" name="dataModel"><label for="tabProduct">Product</label></input>


<div class="tab1">

<ul>
<li>A constant expression wraps a number value :</li></ul>

<div>
<pre class="prettyprint linenums">
public class Constant implements NumericExpression {

    Number n;

    public Constant(Number n) {
        this.n = n;
    }

    @Override
    public Number eval(Map&lt;String, Number&gt; variables) {
        return n;
    }

}</pre></div></div>


<div class="tab2">

<ul>
<li>A variable expression wraps a variable name and can be resolved with the context :</li></ul>

<div>
<pre class="prettyprint linenums">
public class Variable implements NumericExpression {

    String name;

    public Variable(String name) {
        this.name = name;
    }

    @Override
    public Number eval(Map&lt;String, Number&gt; variables) {
        return variables.get(this.name);
    }

}</pre></div></div>


<div class="tab3">

<ul>
<li>An exponent expression is made of a base and an exponent :</li></ul>

<div>
<pre class="prettyprint linenums">
public class Exponent implements NumericExpression {

    NumericExpression base;
    NumericExpression exponent;

    public Exponent(NumericExpression base, NumericExpression exponent) {
        this.base = base;
        this.exponent = exponent;
    }

    @Override
    public Number eval(Map&lt;String, Number&gt; variables) {
        Number base = this.base.eval(variables);
        Number exponent = this.exponent.eval(variables);
        return Math.pow(base.doubleValue(), exponent.doubleValue());
    }
}</pre></div></div>


<div class="tab4">

<input class="tab1" id="tabFuncModel" type="radio" name="dataModelFunc" checked="checked"><label for="tabFuncModel">Model</label></input>
<input class="tab2" id="tabFuncGrammar" type="radio" name="dataModelFunc"><label for="tabFuncGrammar">Grammar</label></input>


<div class="tab1">

<ul>
<li>A function expression embeds an evaluable function :</li></ul>

<div>
<pre class="prettyprint linenums">
public class Function implements NumericExpression {

    NumericExpression argument;
    EvaluableFunction function;

    public Function(EvaluableFunction function, NumericExpression argument) {
        this.function = function;
        this.argument = argument;
    }

    @Override
    public Number eval(Map&lt;String, Number&gt; variables) {
        Number arg = this.argument.eval(variables);
        return function.eval(arg);
    }

}</pre></div>


<div>
<pre class="prettyprint linenums">
public interface EvaluableFunction {

    Number eval(Number value);
}</pre></div>
</div>


<div class="tab2">

<p>In the <tt>Calc</tt> grammar, we enhance the enum class accordingly :</p>

<div>
<pre class="prettyprint linenums">
    // FUNCTION ::= 'sin' | 'cos' | 'exp' | 'ln' | 'sqrt'
    enum Function implements EvaluableFunction {
        sin {
            @Override
            public java.lang.Number eval(java.lang.Number value) {
                return Math.sin(value.doubleValue());
            }
        },
        cos {
            @Override
            public java.lang.Number eval(java.lang.Number value) {
                return Math.cos(value.doubleValue());
            }
        },
        exp {
            @Override
            public java.lang.Number eval(java.lang.Number value) {
                return Math.exp(value.doubleValue());
            }
        },
        ln {
            @Override
            public java.lang.Number eval(java.lang.Number value) {
                return Math.log(value.doubleValue());
            }
        },
        sqrt {
            @Override
            public java.lang.Number eval(java.lang.Number value) {
                return Math.sqrt(value.doubleValue());
            }
        };
    }
    Token FUNCTION = is(Function.class);</pre></div></div>
</div>


<div class="tab5">

<ul>
<li>A term is an expression bound with an operation that appears in sums or products :</li></ul>

<div>
<pre class="prettyprint linenums">
public class Term&lt;T&gt; implements NumericExpression {
    T operation;
    NumericExpression term;

    public Term(T operation, NumericExpression term) {
        this.operation = operation;
        this.term = term;
    }

    @Override
    public Number eval(Map&lt;String, Number&gt; variables) {
        return (this.operation == Additive.MINUS) ?
            - term.eval(variables).doubleValue() :
            + term.eval(variables).doubleValue();
        // alone, a term can have +a or -a but can't have *a or /a
    }
}</pre></div></div>


<div class="tab6">

<div>
<pre class="prettyprint linenums">
public class Sum implements NumericExpression {

    List&lt;Term&lt;Additive&gt;&gt; arguments = new ArrayList&lt;&gt;();

    public Sum(List&lt;Term&lt;Additive&gt;&gt; arguments) {
        this.arguments = arguments;
    }

    @Override
    public Number eval(Map&lt;String, Number&gt; variables) {
        double sum = this.arguments.stream()
            .mapToDouble(t -&gt; (t.operation == Additive.MINUS) ?
                        - t.term.eval(variables).doubleValue()
                    :   + t.term.eval(variables).doubleValue())
            .sum();
        return sum;
    }

}</pre></div></div>


<div class="tab7">

<div>
<pre class="prettyprint linenums">
public class Product implements NumericExpression {

    List&lt;Term&lt;Multiplicative&gt;&gt; arguments = new ArrayList&lt;&gt;();

    public Product(List&lt;Term&lt;Multiplicative&gt;&gt; arguments) {
        this.arguments = arguments;
    }

    @Override
    public Number eval(Map&lt;String, Number&gt; variables) {
        double product = this.arguments.stream()
            .reduce(1d,
                (val, term) -&gt; term.operation == Multiplicative.DIV ?
                        val / term.term.eval(variables).doubleValue()
                    :   val * term.term.eval(variables).doubleValue(),
                (t1, t2) -&gt; t1 * t2);
        return product;
    }

}</pre></div></div>
</div>
<p>Here is the complete code of <a class="externalLink" href="https://github.com/alternet/alternet.ml/blob/master/parsing/src/test/java/ml/alternet/parser/step4/NumericExpression.java"><tt>NumericExpression</tt></a></p>
<p><a name="ast"></a></p></div>
<div class="section">
<h3><a name="AST_builder"></a>AST builder</h3>
<p>As mentionned previously, a node builder can be designed from our <tt>Calc</tt> grammar instance.</p>
<p>We just need to map every token to the relevant class, and every rule to the relevant class. For that purpose, we will use <a href="apidocs/ml/alternet/parser/ast/TokenMapper.html"><tt>TokenMapper&lt;T&gt;</tt></a> and <a href="apidocs/ml/alternet/parser/ast/RuleMapper.html"><tt>RuleMapper&lt;T&gt;</tt></a> where <tt>&lt;T&gt;</tt> is our <tt>&lt;NumericExpression&gt;</tt>. The simplest way to create such mappers is to enumerate the mappings :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    enum CalcTokens implements TokenMapper&lt;NumericExpression&gt; {
        FUNCTION,    // implementation code supplied later
        RAISED,
        ADDITIVE,
        MULTIPLICATIVE,
        NUMBER,
        VARIABLE
    }

    enum CalcRules implements RuleMapper&lt;NumericExpression&gt; {
        Sum,    // implementation code supplied later
        Product,
        Factor
    }
</pre></div></div>
<p>You might notice that the name of the token mappers as well as the name of the rule mappers are the same than those defined in the <tt>Calc</tt> grammar, this is why the mapping will work. You also might notice that some rules in the grammar are not defined here, which means that their tokens will be simply pass to the enclosing rule. Tokens marked as <tt>@Fragment</tt> as well as tokens that are aggregated (enclosed in a rule exposed as a token with <tt>.asToken(...)</tt>) are not present either in the mappings.</p>
<p><a name="nodeBuilder"></a></p>
<div class="section">
<h4><a name="Node_builder"></a>Node builder</h4>
<p>From this base, we are able to build our node builder :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public class ExpressionBuilder extends NodeBuilder&lt;NumericExpression&gt; {

    public ExpressionBuilder() {
        super(Calc.$);
        setTokenMapper(CalcTokens.class);
        setRuleMapper(CalcRules.class);
    }

}
</pre></div></div>
<p>And run the result :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Map&lt;String, Number &gt; variables = new HashMap&lt;&gt;();
    variables.put(&quot;x&quot;, 1.0);
    variables.put(&quot;var_12&quot;, 10.0);

    Optional&lt;NumericExpression&gt; exp = new ExpressionBuilder().parse(&quot;sin( x )* (1 + var_12)&quot;, true);
    Number result = exp.get().eval(variables);
</pre></div></div>
<p><a name="mappers"></a></p></div>
<div class="section">
<h4><a name="AST_mappers"></a>AST mappers</h4>
<p>What is missing is the implementation of each mapper <tt>CalcTokens</tt> and <tt>CalcRules</tt>.</p>

<div style="columns: 2">

<div>

<p>The signature of a token mapper is :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
    Node transform(
            ValueStack&lt;Value&lt;Node&gt;&gt; stack,
            TokenValue&lt;?&gt; token,
            Deque&lt;Value&lt;Node&gt;&gt; next);
</pre></div></div>
</div>

<div style="break-before: column">

<p>The signature of a rule mapper is :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
    Node transform(
            ValueStack&lt;Value&lt;Node&gt;&gt; stack,
            Rule rule,
            Deque&lt;Value&lt;Node&gt;&gt; args);

</pre></div></div>
</div>
</div>
<p>They are both very similar, and apply to the <tt>&lt;Node&gt;</tt> type, which is in our builder the <tt>&lt;NumericExpression&gt;</tt> type :</p>

<ul>
  
<li>The first parameter contains the <b>stack</b> of raw items encountered so far. &#x201c;Raw&#x201d; means that they are not yet transformed since the production is performed bottom up. &#x201c;Raw&#x201d; items are just typed token values produced by the grammar. The more often the stack doesn&#x2019;t serve the transformation but sometimes it may help to peek the last previous item.</li>
  
<li>The second parameter is the current <b>token</b> / <b>rule</b>.</li>
  
<li>The last parameter contains all the values that are either the <b>arguments</b> of the rule to transform, or all the values coming <b>next</b> from the token to transform in the context of its enclosed rule. That values can be raw values or transformed values, according to how you process them individually. In fact <tt>Value&lt;NumericExpression&gt;</tt> is a wrapper around an object that can be either the raw token value <tt>TokenValue&lt;T&gt;</tt> or a <tt>NumericExpression</tt>. You are free to supply token values left as-is or transformed ones, and to get the raw value with <a href="apidocs/ml/alternet/parser/util/Dual.html#getSource--"><tt>.getSource()</tt></a> or the transformed one with <a href="apidocs/ml/alternet/parser/util/Dual.html#getTarget--"><tt>.getTarget()</tt></a> as long as you are aware that the types you produce may be consumed.</li>
</ul>
<p>For example, if a rule defines a comma-separated list of digits such as &#x201c;<tt>1,2,3,4</tt>&#x201d;, that the input is &#x201c;<tt>i=<b>1,2,3,4</b>;</tt>&#x201d;, and that the current <b>token</b> is &#x201c;<tt>2</tt>&#x201d;, then the <b>next</b> elements are &#x201c;<tt>,3,4</tt>&#x201d; (note that <tt>;</tt> is outside of the rule considered and <b>not</b> within the next elements) and the stack is &#x201c;<tt>i=1,</tt>&#x201d; (note that &#x201c;<tt>i=</tt>&#x201d; are tokens outside of the scope of the rule considered, but <b>present</b> in the stack). Some elements may be consumed during the production of the target node.</p>
<p>In our enum classes <tt>CalcTokens</tt> and <tt>CalcRules</tt>, we are creating a constructor that accept the mapper to which the transformation will be delegated. This let us using a lambda in our enum values :</p>

<div class="tabs">

<input class="tab1" id="tabCalcRules" type="radio" name="calcMappers" checked="checked"><label for="tabCalcRules">CalcRules</label></input>
<input class="tab2" id="tabCalcTokens" type="radio" name="calcMappers" checked="checked"><label for="tabCalcTokens">CalcTokens</label></input>


<div class="tab1">
<div>
<pre class="prettyprint linenums">
enum CalcRules implements RuleMapper&lt;NumericExpression&gt; {

    Sum( (stack, rule, args) -&gt; {} ),    // implementation code supplied later
    Product( (stack, rule, args) -&gt; {} ),
    Factor( (stack, rule, args) -&gt; {} );

    RuleMapper&lt;NumericExpression&gt; mapper;

    CalcRules(RuleMapper&lt;NumericExpression&gt; mapper) { // pass the mapper to the constructor
        this.mapper = mapper;
    }

    @Override
    public NumericExpression transform(
            ValueStack&lt;Value&lt;NumericExpression&gt;&gt; stack,
            Rule rule,
            Deque&lt;Value&lt;NumericExpression&gt;&gt; args)
    {
        return this.mapper.transform(stack, rule, args); // delegate the mapping
    }

}</pre></div></div>


<div class="tab2">
<div>
<pre class="prettyprint linenums">
enum CalcTokens implements TokenMapper&lt;NumericExpression&gt; {

    FUNCTION( (stack, token, next) -&gt; {} ),    // implementation code supplied later
    RAISED( (stack, token, next) -&gt; {} ),
    ADDITIVE( (stack, token, next) -&gt; {} ),
    MULTIPLICATIVE( (stack, token, next) -&gt; {} ),
    NUMBER( (stack, token, next) -&gt; {} ),
    VARIABLE( (stack, token, next) -&gt; {} );

    TokenMapper&lt;NumericExpression&gt; mapper;

    CalcTokens(TokenMapper&lt;NumericExpression&gt; mapper) { // pass the mapper to the constructor
        this.mapper = mapper;
    }

    @Override
    public NumericExpression transform(
        ValueStack&lt;Value&lt;NumericExpression&gt;&gt; stack,
        TokenValue&lt;?&gt; token,
        Deque&lt;Value&lt;NumericExpression&gt;&gt; next)
    {
        return this.mapper.transform(stack, token, next); // delegate the mapping
    }

}</pre></div>
</div>

</div>
<p><a name="tokenMappers"></a></p></div>
<div class="section">
<h4><a name="Token_mappers"></a>Token mappers</h4>
<p>Now we can focus on the mappers inside <tt>enum CalcTokens</tt>, starting with the simplest ones :</p>

<div class="tabs">

<input class="tab1" id="tabVARIABLE" type="radio" name="tokenMappers" checked="checked"><label for="tabVARIABLE">VARIABLE</label></input>
<input class="tab2" id="tabNUMBER" type="radio" name="tokenMappers"><label for="tabNUMBER">NUMBER</label></input>
<input class="tab3" id="tabFUNCTION" type="radio" name="tokenMappers"><label for="tabFUNCTION">FUNCTION</label></input>
<input class="tab4" id="tabRAISED" type="radio" name="tokenMappers"><label for="tabRAISED">RAISED</label></input>
<input class="tab5" id="tabMULTIPLICATIVE" type="radio" name="tokenMappers"><label for="tabMULTIPLICATIVE">MULTIPLICATIVE</label></input>
<input class="tab6" id="tabADDITIVE" type="radio" name="tokenMappers"><label for="tabADDITIVE">ADDITIVE</label></input>


<div class="tab1">

<ul>
<li>the <tt>VARIABLE</tt> <b>token</b> is just a sequence of characters, we write the <tt>VARIABLE</tt> <b>mapper</b> (with the same name as the token) that create a <tt>Variable</tt> <b>instance</b> from our data model with that token :</li></ul>

<div>
<pre class="prettyprint linenums">
    VARIABLE( (stack, token, next) -&gt; {
        // mapper for : Token VARIABLE = ( (LOWERCASE).or( &lt;etc...&gt; ).asToken()
        String name = token.getValue();
        return new Variable(name);
    });</pre></div>
</div>


<div class="tab2">

<ul>
<li>the <tt>NUMBER</tt> token is produced in the grammar with <a href="apidocs/ml/alternet/parser/Grammar.Rule.html#asNumber--"><tt>.asNumber()</tt></a>, we write the <tt>NUMBER</tt> mapper that create a <tt>Constant</tt> instance from our data model with that number token :</li></ul>

<div>
<pre class="prettyprint linenums">
    NUMBER( (stack, token, next) -&gt; {
        // mapper for : Token NUMBER = DIGIT.oneOrMore().asNumber();
        Number n = token.getValue(); // thanks to &quot;.asNumber();&quot;
        return new Constant(n);
    }),</pre></div>
</div>


<div class="tab3">

<ul>
<li>the <tt>FUNCTION</tt> token is produced in the grammar with the <tt>Calc.Function</tt> enum class, we write the <tt>FUNCTION</tt> mapper that create a <tt>Function</tt> instance from our data model with that enum value token. In our grammar, functions are taking a single argument, we can retrieve it as the next following value :</li></ul>

<div>
<pre class="prettyprint linenums">
    FUNCTION( (stack, token, next) -&gt; {
        // mapper for : Token FUNCTION = is(Calc.Function.class);
        // e.g.   sin  x
        //   function  argument
        Operation.Function function = token.getValue();            // e.g.   Calc.Function.sin
        NumericExpression argument = next.pollFirst().getTarget(); // e.g.   Expression.Variable(&quot;x&quot;)
        return new Function(function, argument);
    }),</pre></div>
</div>


<div class="tab4">

<ul>
<li>the <tt>RAISED</tt> token is a little special because it uses the previous item and the next one. Unfortunately, the previous item (which is in the stack) is not yet transformed to a <tt>NumericExpression</tt>, therefore we can't do something useful in that mapper : we must delegate the mapping to the enclosed rule mapper <tt>Factor</tt> (see later) :</li></ul>

<div>
<pre class="prettyprint linenums">
    RAISED( (stack, token, next) -&gt;
        // mapper for : Token RAISED = is('^');
        // e.g. a ^ b
        null // we don't know how to process it here =&gt; keep the source value
    ),</pre></div>
</div>


<div class="tab5">

<ul>
<li>the <tt>MULTIPLICATIVE</tt> token is produced in the grammar with the <tt>Calc.Multiplicative</tt> enum class. It is transformed to a <tt>Term&lt;Calc.Multiplicative&gt;</tt> ; the grammar say that the token is <b>always</b> followed by an argument :</li></ul>

<div>
<pre class="prettyprint linenums">
    MULTIPLICATIVE( (stack, token, next) -&gt; {
        // mapper for : Token MULTIPLICATIVE = is(Multiplicative.class);
        // e.g. a * b
        Multiplication op = token.getValue(); // * | /
        // * is always followed by an argument
        NumericExpression arg = next.pollFirst().getTarget(); // b argument
        Term&lt;Multiplication&gt; term = new Term&lt;&gt;(op, arg);
        return term;
    }),</pre></div>
</div>


<div class="tab6">

<ul>
<li><tt>Calc.Additive</tt> is slightly different because it always appears alone in <tt>SignedTerm</tt> and <tt>SignedFactor</tt>. Both rules are wrapping the additive term <b>within</b> an optional rule, which means that <b>nothing</b> comes next in that rule.</li></ul>


<div style="columns: 2">

<div>

<p>Aside, <tt>Product</tt> or <tt>Factor</tt> are after the optional rule, <b>not after</b> the <tt>ADDITIVE</tt> term, which means that we have to consider just <tt>ADDITIVE?</tt> as the enclosed rule.</p>
</div>

<div style="break-before: column">

<div class="source">
<div class="source">
<pre class="prettyprint">
SignedTerm   ::= ADDITIVE? Product
SignedFactor ::= ADDITIVE? Factor
</pre></div></div>
</div>
</div>


<div style="columns: 2">

<div>

<p>Conversely, in a <tt>Sum</tt>, the <tt>ADDITIVE</tt> term is <b>always</b> followed by a term.</p>
</div>

<div style="break-before: column">

<div class="source">
<div class="source">
<pre class="prettyprint">
Sum ::= SignedTerm (ADDITIVE Product)*
</pre></div></div>
</div>
</div>


<p>A partial dump allow to visualize the relevant rules and compare them :</p>
<input class="tab1" id="tabSTermDump" type="radio" name="partialDump" checked="checked"><label for="tabSTermDump">SignedTerm</label></input>
<input class="tab2" id="tabSFactorDump" type="radio" name="partialDump"><label for="tabSFactorDump">SignedFactor</label></input>
<input class="tab3" id="tabSumDump" type="radio" name="partialDump"><label for="tabSumDump">Sum</label></input>
<input class="tab4" id="tabCodeDump" type="radio" name="partialDump"><label for="tabCodeDump">Java code</label></input>
<input class="tab5" id="tabWhyDump" type="radio" name="partialDump"><label for="tabWhyDump">Why ?</label></input>

<div class="tab1">

<p><tt>ADDITIVE</tt> <b>is not</b> followed by <tt>Product</tt>, but <tt>ADDITIVE ?</tt> is followed by <tt>Product</tt></p>

<div class="source">
<div class="source">
<pre class="prettyprint" style="line-height: 17px">
SignedTerm
&#x2523;&#x2501;&#x2501; ADDITIVE?
&#x2503;   &#x2517;&#x2501;&#x2501; ADDITIVE &#x2501;&#x2501;&#x2501; ( '+' | '-' )
&#x2517;&#x2501;&#x2501; Product</pre></div>
</div>
</div>

<div class="tab2">

<p><tt>ADDITIVE</tt> <b>is not</b> followed by <tt>Factor</tt></p>

<div class="source">
<div class="source">
<pre class="prettyprint" style="line-height: 17px">
SignedFactor
&#x2517;&#x2501;&#x2501; ( ADDITIVE? Factor )
    &#x2523;&#x2501;&#x2501; ADDITIVE?
    &#x2503;   &#x2517;&#x2501;&#x2501; ADDITIVE &#x2501;&#x2501;&#x2501; ( '+' | '-' )
    &#x2517;&#x2501;&#x2501; Factor</pre></div>
</div>
</div>

<div class="tab3">

<p><tt>ADDITIVE</tt> <b>IS</b> followed by <tt>Product</tt> !!!</p>

<div class="source">
<div class="source">
<pre class="prettyprint" style="line-height: 17px">
Sum
&#x2517;&#x2501;&#x2501; ( SignedTerm ( ADDITIVE Product )* )
    &#x2523;&#x2501;&#x2501; SignedTerm
    &#x2517;&#x2501;&#x2501; ( ADDITIVE Product )*
        &#x2517;&#x2501;&#x2501; ( ADDITIVE Product )
            &#x2523;&#x2501;&#x2501; ADDITIVE &#x2501;&#x2501;&#x2501; ( '+' | '-' )
            &#x2517;&#x2501;&#x2501; Product</pre></div></div>
</div>

<div class="tab4">

<p>Java program allowing to dump a rule or token :</p>

<div>
<pre class="prettyprint linenums">
    Dump dump = new Dump().withoutClass()
                          .withoutHash()
                          .setVisited(Calc.SignedTerm) // we don't want to dump
                          .setVisited(Calc.Product);   // those subtrees
    Calc.Sum.accept(dump);
    System.out.println(dump);</pre></div></div>


<div class="tab5">
Why <tt>SignedTerm</tt> and <tt>SignedFactor</tt> doesn't look the same in the dump ? This is because <tt>SignedFactor</tt> is not defined directly but is enclosed in a proxy rule, unlike <tt>SignedTerm</tt> :

<div>
<pre class="prettyprint linenums">
    Rule SignedTerm = ADDITIVE.optional().seq(Product);
    Rule SignedFactor = $(() -&gt; ADDITIVE.optional().seq(Calc.Factor));</pre></div>
</div>


<p>Therefore, we can check what comes next to decide if we can create a <tt>Term&lt;Calc.Additive&gt;</tt> :</p>

<div>
<pre class="prettyprint linenums">
    ADDITIVE( (stack, token, next) -&gt; {
        // mapper for : Token ADDITIVE = is(Additive.class);
        // e.g. a + b
        Addition op = token.getValue(); // + | -
        if (next.isEmpty()) {
            // SignedTerm   ::= ADDITIVE? Product
            // SignedFactor ::= ADDITIVE? Factor
            return null; // raw value Additive
        } else {
            // + is always followed by an argument
            // Sum ::= SignedTerm (ADDITIVE Product)*
            NumericExpression arg = next.pollFirst().getTarget(); // b argument
            Term&lt;Addition&gt; term = new Term&lt;&gt;(op, arg);
            return term;
        }
    }),</pre></div>
</div>

</div>
<p><a name="ruleMappers"></a></p></div>
<div class="section">
<h4><a name="Rule_mappers"></a>Rule mappers</h4>
<p>The last but not the least is to map the rules inside <tt>enum CalcRules</tt>.</p>

<div class="tabs">

<input class="tab1" id="tabFactorMapper" type="radio" name="ruleMappers" checked="checked"><label for="tabFactorMapper">Factor</label></input>
<input class="tab2" id="tabProductMapper" type="radio" name="ruleMappers"><label for="tabProductMapper">Product</label></input>
<input class="tab3" id="tabSumMapper" type="radio" name="ruleMappers"><label for="tabSumMapper">Sum</label></input>


<div class="tab1">

<ul>
<li>let's start with the <tt>Factor</tt> rule, that handles the <tt>RAISED</tt> token. But this time, all values are available within the <b>arguments</b> :</li></ul>

<div>
<pre class="prettyprint linenums">
    Factor( (stack, rule, args) -&gt; { // mapper for : Rule Factor = ...
        // Factor ::= Argument ('^' SignedFactor)?
        //              base         exponent
        NumericExpression base = args.pollFirst().getTarget();
        Value&lt;NumericExpression&gt; raised = args.peekFirst();
        if (raised != null &amp;&amp; raised.isSource() &amp;&amp; raised.getSource().getRule() == Calc.RAISED) {
            args.pollFirst(); // ^
            NumericExpression exponent = args.pollFirst().getTarget();
            return new Exponent(base, exponent);
        } else {
            // a single term is not a factor
            return base;
        }
    });</pre></div>

<p>Note that the <tt>Factor</tt> mapper doesn't necessary give an <tt>Exponent</tt> instance. Sometimes it is traversed because it doesn't contain the <tt>^</tt> token. In that case we return the argument as-is.</p>

<p>Similarly, for the <tt>Sum</tt> and <tt>Product</tt> mappers, the semantic of the grammar allow to traverse the counterpart rules without producing the target instances.</p>
</div>


<div class="tab2">

<ul>
<li>the <tt>Product</tt> mapper is more simpler than the <tt>Sum</tt> mapper :</li></ul>

<div>
<pre class="prettyprint linenums">
    Product( (stack, rule, args) -&gt; { // mapper for : Rule Product = ...
        // Product ::= Factor (MULTIPLICATIVE SignedFactor)*
        if (args.size() == 1) {
            // a single term is not a product
            return args.pollFirst().getTarget();
        } else {
            // assume x to be *x, because the product will start by 1*x
            Term&lt;Multiplication&gt; factor = new Term&lt;&gt;(Multiplicative.MULT, args.removeFirst().getTarget());
            List&lt;Term&lt;Multiplication&gt;&gt; arguments = new LinkedList&lt;&gt;();
            arguments.add(factor);
            args.stream()
                // next arguments are all Term&lt;Multiplicative&gt;
                .map(v -&gt; (Term&lt;Multiplication&gt;) v.getTarget())
                .forEachOrdered(arguments::add);
            return new Product(arguments);
        }
    }),</pre></div>
</div>


<div class="tab3">

<ul>
<li>for the <tt>Sum</tt> rule, when we do have several arguments, we must check whether the first term had a sign, or was just an argument, and transform it to conform with the signature of the target constructor :</li></ul>

<div>
<pre class="prettyprint linenums">
    Sum( (stack, rule, args) -&gt; { // mapper for : Rule Sum = ...
        // Sum ::= SignedTerm (ADDITIVE Product)*
        if (args.size() == 1) {
            // a single term is not a sum
            return args.pollFirst().getTarget();
        } else {
            NumericExpression signedTerm = args.removeFirst().getTarget();
            if (! (signedTerm instanceof Term&lt;?&gt;)
                || ! (((Term&lt;?&gt;) signedTerm).operator instanceof Addition)) {
                // force &quot;x&quot; to be &quot;+x&quot;
                signedTerm = new Term&lt;&gt;(Additive.PLUS, signedTerm);
            }
            List&lt;Term&lt;Addition&gt;&gt; arguments = new LinkedList&lt;&gt;();
            arguments.add((Term&lt;Addition&gt;) signedTerm);
            args.stream()
                // next arguments are all Term&lt;Additive&gt;
                .map(v -&gt; (Term&lt;Addition&gt;) v.getTarget())
                .forEachOrdered(arguments::add);
            return new Sum(arguments);
        }
    }),</pre></div>
</div>

</div>
<hr />
<p>Here is the complete code of <a class="externalLink" href="https://github.com/alternet/alternet.ml/blob/master/parsing/src/test/java/ml/alternet/parser/step4/ExpressionBuilder.java"><tt>ExpressionBuilder</tt></a></p>
<p>You may wonder whether to use the &#x201c;typed token&#x201d; technique or this &#x201c;AST builder&#x201d; ? Well, the former is certainly easier to use, but the latter gives you more context for the mapping ; it is taken in charge by the handler in the parsing phase.</p>
<p>Even if the <a href="apidocs/ml/alternet/parser/ast/NodeBuilder.html"><tt>NodeBuilder</tt></a> can deal with homogeneous node types, we will see in the next section how easily we can expose a grammar as a token, and therefore having the capability to mix different node types.</p>
<p><a name="grammarToken"></a></p></div></div>
<div class="section">
<h3><a name="A_grammar_as_a_token"></a>A grammar as a token</h3>
<p>Sometimes it is preferable to expose a grammar as a token rather than extending an existing grammar.</p>
<p>For example, imagine that our expression <tt>sin( x ) * ( 1 + var_12 )</tt> always appear in fact in value templates, delimited with <tt>{</tt> and <tt>}</tt> :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
the result of the expression sin(x)*(1+var_12) is { sin(x)*(1+var_12) } !
</pre></div></div>
<p>Everything between the curly braces is the expression, and everything around is just text, and after parsing and evaluating, we expect this output :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
the result of the expression sin(x)*(1+var_12) is 42 !
</pre></div></div>
<p>(as an exercise you can find a couple for x and var_12 that gives 42)</p>
<p>To achieve this, we need a new grammar, but instead of extending our <tt>Calc</tt> grammar, we simply expose it as a token :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public interface ValueTemplate extends Grammar {

    @Fragment Token LCB = is('{');
    @Fragment Token RCB = is('}');

    Token ESCAPE_LCB = is(&quot;{{&quot;); // a double {{ is an escape for {
    Token ESCAPE_RCB = is(&quot;}}&quot;); // a double }} is an escape for }

    //   EXPRESSION ::= Calc
    Token EXPRESSION = is(
            Calc.$,
            () -&gt; new ExpressionBuilder());

    Rule Text = ESCAPE_LCB.or(ESCAPE_RCB, isnot(LCB, RCB)).zeroOrMore();

    @MainRule
    Rule ValueTemplate = Text.seq(EXPRESSION.optional()).zeroOrMore();

    ValueTemplate $ = $();

}
</pre></div></div>
<p>We are using our <tt>Calc</tt> grammar jointly with <tt>ExpressionBuilder()</tt> for parsing an expression to a <tt>NumericExpression</tt>. This is exposed in the token <tt>EXPRESSION</tt>.</p>
<p>This approach is preferable than extending a grammar when the target result type differs from the other grammar. In our case, an expression is evaluated to a number, whereas a value template expression is evaluated to a string.</p>
<p>Here is how we can evaluate such expression :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Map&lt;String, Number&gt; variables = new HashMap&lt;&gt;();
    variables.put(&quot;x&quot;, 1.0);
    variables.put(&quot;var_12&quot;, 10.0);

    Optional&lt;StringExpression&gt; exp = new ValueTemplateBuilder()
        .parse(expression, true);

    String res = exp.get().eval(variables);
</pre></div></div>
<p>You can examine the code of the <a class="externalLink" href="https://github.com/alternet/alternet.ml/blob/master/parsing/src/test/java/ml/alternet/parser/step4/ValueTemplateBuilder.java"><tt>ValueTemplateBuilder</tt></a> and <a class="externalLink" href="https://github.com/alternet/alternet.ml/blob/master/parsing/src/test/java/ml/alternet/parser/step4/StringExpression.java"><tt>StringExpression</tt></a> on Github.</p>
<p><a name="extendingMapping"></a></p></div>
<div class="section">
<h3><a name="Extending_the_mappings"></a>Extending the mappings</h3>
<p>We already extend our <tt>Calc</tt> grammar to the <tt>Math</tt> grammar, by rewriting some rules and tokens. Those rewritings has an impact on our mappings. We have to rewrite those that changed accordingly.</p>
<p>First, our custom model is not really ideal for extension : our additions and multiplications are just exposed as enum values, whereas their underlying operations should be exposed as interfaces. This let us rewrite more easily a new multiplication with <tt>&#xd7;</tt> and <tt>&#xf7;</tt> instead of <tt>*</tt> and <tt>/</tt> : with an interface, we don&#x2019;t change the operation, just the token.</p>

<div class="alert alert-info" role="alert">
Each time an enum is defined in a grammar, it should implement an interface in order to ease extensibility.
</div>
<p>With that enhancements, it is really easy to extend the existing mappings (the extension of <tt>Calc</tt> to <tt>Math</tt> has been discussed previously). You can check them here : <a class="externalLink" href="https://github.com/alternet/alternet.ml/blob/master/parsing/src/test/java/ml/alternet/parser/step6/Calc.java"><tt>Calc</tt></a> as well as <a class="externalLink" href="https://github.com/alternet/alternet.ml/blob/master/parsing/src/test/java/ml/alternet/parser/step6/ExpressionBuilder.java"><tt>ExpressionBuilder</tt></a>, now use <a class="externalLink" href="https://github.com/alternet/alternet.ml/blob/master/parsing/src/test/java/ml/alternet/parser/step6/Operation.java"><tt>Operation</tt>s</a> ; the extension grammar <a class="externalLink" href="https://github.com/alternet/alternet.ml/blob/master/parsing/src/test/java/ml/alternet/parser/step6/Math.java"><tt>Math</tt></a> also uses operations, and we will use them in <tt>MathExpressionBuilder</tt> (see below).</p>
<p>Here is a reminder of the changes :</p>

<div class="source">
<div class="source">
<pre class="prettyprint">
[03] FUNCTION       ::= 'sin' | 'cos' | 'exp' | 'ln' | 'sqrt' | 'asin' | 'acos'
[05] MULTIPLICATIVE ::= '&#xd7;' | '&#xf7;'
[11] VARIABLE       ::= UPPERCASE (UPPERCASE | DIGIT | UNDERSCORE)*

[14] Argument       ::= FUNCTION LBRACKET Argument RBRACKET | Value | LBRACKET Expression RBRACKET
</pre></div></div>
<p>In fact, with our enhanced data model, the sole impact is around the multiplicative operation because the enum class changed ; therefore we need to rewrite the mapping where it is produced (the <tt>MULTIPLICATIVE</tt> mapper) and where it is consumed (the <tt>Product</tt> mapper) :</p>

<div class="tabs">

<input class="tab1" id="tabMathExpressionBuilder" type="radio" name="mathBuilder" checked="checked"><label for="tabMathExpressionBuilder">MathExpressionBuilder</label></input>
<input class="tab2" id="tabMathRules" type="radio" name="mathBuilder"><label for="tabMathRules">MathRules</label></input>
<input class="tab3" id="tabMathTokens" type="radio" name="mathBuilder"><label for="tabMathTokens">MathTokens</label></input>


<div class="tab1">
<div>
<pre class="prettyprint linenums">
public class MathExpressionBuilder extends NodeBuilder&lt;NumericExpression&gt; {

    public MathExpressionBuilder() {
        this(Math.$);
    }

    public MathExpressionBuilder(Grammar g) {
        super(g);
        setTokenMapper(MathTokens.class);
        setRuleMapper(MathRules.class);
    }

}</pre></div></div>


<div class="tab2">
<div>
<pre class="prettyprint linenums">
enum MathRules implements RuleMapper&lt;NumericExpression&gt; {

    Product( (stack, rule, args) -&gt; {
        // Product ::= Factor (MULTIPLICATIVE SignedFactor)*
        if (args.size() == 1) {
            // a single term is not a product
            return args.pollFirst().getTarget();
        } else {
            // assume x to be &#xd7;x, because the product will start by 1&#xd7;x
            Term&lt;Multiplication&gt; factor = new Term&lt;&gt;(MathMultiplicative.MULT, args.removeFirst().getTarget());
            List&lt;Term&lt;Multiplication &gt;&gt; arguments = new LinkedList&lt;&gt;();
            arguments.add(factor);
            args.stream()
                // next arguments are all Term&lt;Multiplicative&gt;
                .map(v -&gt; (Term&lt;Multiplication&gt;) v.getTarget())
                .forEachOrdered(arguments::add);
            return new Product(arguments);
        }
    });

    static {
        EnumUtil.extend(ExpressionBuilder.CalcRules.class); // look, Ma ! Easy enum extension !
    }

    RuleMapper&lt;NumericExpression&gt; rm;

    MathRules(ExpressionBuilder.CalcRules cr) { // constructor required by EnumUtil.extend
        this.rm = cr;
    }

    MathRules(RuleMapper&lt;NumericExpression&gt; rm) {
        this.rm = rm;
    }

    @Override
    public NumericExpression transform(
        ValueStack&lt;Value&lt;NumericExpression&gt;&gt; stack,
        Rule rule,
        Deque&lt;Value&lt;NumericExpression&gt;&gt; args)
    {
        return rm.transform(stack, rule, args);
    }

}</pre></div></div>


<div class="tab3">
<div>
<pre class="prettyprint linenums">
enum MathTokens implements TokenMapper&lt;NumericExpression&gt; {

    MULTIPLICATIVE( (stack, token, next) -&gt; {
        // e.g. a &#xd7; b
        MathMultiplicative op = token.getValue(); // &#xd7; | &#xf7;
        // &#xd7; is always followed by an argument
        NumericExpression arg = next.pollFirst().getTarget(); // b argument
        Term&lt;MathMultiplicative&gt; term = new Term&lt;&gt;(op, arg);
        return term;
    });

    static {
        EnumUtil.extend(ExpressionBuilder.CalcTokens.class);
    }

    TokenMapper&lt;NumericExpression&gt; tm;

    MathTokens(ExpressionBuilder.CalcTokens ct) { // constructor required by EnumUtil.extend
        this.tm = ct;
    }

    MathTokens(TokenMapper&lt;NumericExpression&gt; tm) {
        this.tm = tm;
    }

    @Override
    public NumericExpression transform(
        ValueStack&lt;Value&lt;NumericExpression&gt;&gt; stack,
        TokenValue&lt;?&gt; token,
        Deque&lt;Value&lt;NumericExpression&gt;&gt; next)
    {
        return tm.transform(stack, token, next);
    }

}</pre></div></div>

</div>
<p>Finally, if we also expect a value template based on the <tt>Math</tt> builder instead of the <tt>Calc</tt> builder, we just need this new grammar :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public interface MathValueTemplate extends ValueTemplate {

    //    EXPRESSION ::= Math
    Token EXPRESSION = is(
            Math.$,
            () -&gt; new MathExpressionBuilder());

    MathValueTemplate $ = $();

}
</pre></div></div>
<p>We don&#x2019;t need a new builder for this grammar, because the token value produced by <tt>MathExpressionBuilder</tt> is a <tt>NumericExpression</tt>, just like for <tt>ExpressionBuilder</tt>. Therefore, the existing <tt>ValueTemplateBuilder</tt> is just enough, but need a minor update to be able to accept either the <tt>ValueTemplate</tt> grammar or the <tt>MathValueTemplate</tt> grammar.</p>
<p><a name="examples"></a></p></div></div>
<div class="section">
<h2><a name="Additional_examples"></a>Additional examples</h2>
<p>You will find various examples in the <a class="externalLink" href="https://github.com/alternet/alternet.ml/tree/master/parsing/src/test/java/ml/alternet/parser">Github repo</a>.</p>

<ul>
  
<li><a class="externalLink" href="https://github.com/alternet/alternet.ml/blob/master/parsing/src/test/java/ml/alternet/parser/www/WAuth.java">WWW-Authenticate parser</a></li>
  
<li><a class="externalLink" href="https://github.com/alternet/alternet.ml/tree/master/parsing/src/test/java/ml/alternet/parser/step4">Calc grammar and parser</a></li>
  
<li><a class="externalLink" href="https://github.com/alternet/alternet.ml/blob/master/parsing/src/test/java/ml/alternet/parser/examples/Argon2CryptFormatter.java">Argon2 crypt format parser</a> : breakdown the crypt in its parts, decode bytes and supply parameters</li>
</ul>
<p><a name="troubleshooting"></a></p></div>
<div class="section">
<h2><a name="Troubleshooting"></a>Troubleshooting</h2>
<p><a name="dump"></a></p>
<div class="section">
<h3><a name="Dump"></a>Dump</h3>
<p>A convenient tool allow to <a href="apidocs/ml/alternet/parser/visit/Dump.html">dump</a> a rule :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Dump.tree(rule);
    Dump.tree(grammar); // dump the main rule

    Dump.detailed(rule); // displays additional informations about the class
</pre></div></div>
<p>Sometimes, a rule exist in a grammar that has been extended, but that rule hasn&#x2019;t been overriden, therefore, it may be helpful to specify from which grammar we want its dump, since it may affect the content :</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    Dump.tree(Calc.$, Math.Expression); // the original rule
    Dump.tree(Math.$, Math.Expression); // the same rule but altered in the extension grammar
</pre></div></div>
<p>The output looks like this. Every named rule composed is expanded once the first time it is encountered.</p>

<div class="tabs">

<input class="tab1" id="tabExpr" type="radio" name="dump" checked="checked"><label for="tabExpr">Expression</label></input>
<input class="tab2" id="tabArg" type="radio" name="dump"><label for="tabArg">Argument</label></input>


<div class="tab1">

<p>Below is displayed the dump of our <tt>Math</tt> grammar (after rule rewrites) :</p>

<div class="source">
<div class="source">
<pre class="prettyprint" style="line-height: 17px">
Expression
&#x2517;&#x2501;&#x2501; Sum
    &#x2517;&#x2501;&#x2501; ( SignedTerm ( ADDITIVE Product )* )
        &#x2523;&#x2501;&#x2501; SignedTerm
        &#x2503;   &#x2523;&#x2501;&#x2501; ADDITIVE?
        &#x2503;   &#x2503;   &#x2517;&#x2501;&#x2501; ADDITIVE &#x2501;&#x2501;&#x2501; ( '+' | '-' )
        &#x2503;   &#x2517;&#x2501;&#x2501; Product
        &#x2503;       &#x2523;&#x2501;&#x2501; Factor
        &#x2503;       &#x2503;   &#x2523;&#x2501;&#x2501; Argument
        &#x2503;       &#x2503;   &#x2503;   &#x2523;&#x2501;&#x2501; ( FUNCTION LBRACKET Argument RBRACKET )
        &#x2503;       &#x2503;   &#x2503;   &#x2503;   &#x2523;&#x2501;&#x2501; FUNCTION &#x2501;&#x2501;&#x2501; ( 'ln' | 'cos' | 'exp' | 'sin' | 'acos' | 'asin' | 'sqrt' )
        &#x2503;       &#x2503;   &#x2503;   &#x2503;   &#x2523;&#x2501;&#x2501; LBRACKET &#x2501;&#x2501;&#x2501; '('
        &#x2503;       &#x2503;   &#x2503;   &#x2503;   &#x2523;&#x2501;&#x2501; Argument
        &#x2503;       &#x2503;   &#x2503;   &#x2503;   &#x2517;&#x2501;&#x2501; RBRACKET &#x2501;&#x2501;&#x2501; ')'
        &#x2503;       &#x2503;   &#x2503;   &#x2523;&#x2501;&#x2501; Value
        &#x2503;       &#x2503;   &#x2503;   &#x2503;   &#x2523;&#x2501;&#x2501; NUMBER
        &#x2503;       &#x2503;   &#x2503;   &#x2503;   &#x2503;   &#x2517;&#x2501;&#x2501; DIGIT+
        &#x2503;       &#x2503;   &#x2503;   &#x2503;   &#x2503;       &#x2517;&#x2501;&#x2501; DIGIT
        &#x2503;       &#x2503;   &#x2503;   &#x2503;   &#x2503;           &#x2517;&#x2501;&#x2501; ['0'-'9']
        &#x2503;       &#x2503;   &#x2503;   &#x2503;   &#x2517;&#x2501;&#x2501; VARIABLE
        &#x2503;       &#x2503;   &#x2503;   &#x2503;       &#x2517;&#x2501;&#x2501; ( UPPERCASE ( UPPERCASE | DIGIT | UNDERSCORE )* )
        &#x2503;       &#x2503;   &#x2503;   &#x2503;           &#x2523;&#x2501;&#x2501; UPPERCASE &#x2501;&#x2501;&#x2501; ['A'-'Z']
        &#x2503;       &#x2503;   &#x2503;   &#x2503;           &#x2517;&#x2501;&#x2501; ( UPPERCASE | DIGIT | UNDERSCORE )*
        &#x2503;       &#x2503;   &#x2503;   &#x2503;               &#x2517;&#x2501;&#x2501; ( UPPERCASE | DIGIT | UNDERSCORE )
        &#x2503;       &#x2503;   &#x2503;   &#x2503;                   &#x2523;&#x2501;&#x2501; UPPERCASE &#x2501;&#x2501;&#x2501; ['A'-'Z']
        &#x2503;       &#x2503;   &#x2503;   &#x2503;                   &#x2523;&#x2501;&#x2501; DIGIT
        &#x2503;       &#x2503;   &#x2503;   &#x2503;                   &#x2517;&#x2501;&#x2501; UNDERSCORE &#x2501;&#x2501;&#x2501; '_'
        &#x2503;       &#x2503;   &#x2503;   &#x2517;&#x2501;&#x2501; ( LBRACKET Expression RBRACKET )
        &#x2503;       &#x2503;   &#x2503;       &#x2523;&#x2501;&#x2501; LBRACKET &#x2501;&#x2501;&#x2501; '('
        &#x2503;       &#x2503;   &#x2503;       &#x2523;&#x2501;&#x2501; Expression
        &#x2503;       &#x2503;   &#x2503;       &#x2517;&#x2501;&#x2501; RBRACKET &#x2501;&#x2501;&#x2501; ')'
        &#x2503;       &#x2503;   &#x2517;&#x2501;&#x2501; ( RAISED SignedFactor )?
        &#x2503;       &#x2503;       &#x2517;&#x2501;&#x2501; ( RAISED SignedFactor )
        &#x2503;       &#x2503;           &#x2523;&#x2501;&#x2501; RAISED &#x2501;&#x2501;&#x2501; '^'
        &#x2503;       &#x2503;           &#x2517;&#x2501;&#x2501; SignedFactor
        &#x2503;       &#x2503;               &#x2517;&#x2501;&#x2501; ( ADDITIVE? Factor )
        &#x2503;       &#x2503;                   &#x2523;&#x2501;&#x2501; ADDITIVE?
        &#x2503;       &#x2503;                   &#x2503;   &#x2517;&#x2501;&#x2501; ADDITIVE &#x2501;&#x2501;&#x2501; ( '+' | '-' )
        &#x2503;       &#x2503;                   &#x2517;&#x2501;&#x2501; Factor
        &#x2503;       &#x2517;&#x2501;&#x2501; ( MULTIPLICATIVE SignedFactor )*
        &#x2503;           &#x2517;&#x2501;&#x2501; ( MULTIPLICATIVE SignedFactor )
        &#x2503;               &#x2523;&#x2501;&#x2501; MULTIPLICATIVE &#x2501;&#x2501;&#x2501; ( '&#xd7;' | '&#xf7;' )
        &#x2503;               &#x2517;&#x2501;&#x2501; SignedFactor
        &#x2517;&#x2501;&#x2501; ( ADDITIVE Product )*
            &#x2517;&#x2501;&#x2501; ( ADDITIVE Product )
                &#x2523;&#x2501;&#x2501; ADDITIVE &#x2501;&#x2501;&#x2501; ( '+' | '-' )
                &#x2517;&#x2501;&#x2501; Product
</pre></div></div>
</div>


<div class="tab2"> 

<p>The dump of <tt>Argument</tt> in the <tt>Math</tt> grammar :</p>

<div class="source">
<div class="source">
<pre class="prettyprint" style="line-height: 17px">
Argument
&#x2523;&#x2501;&#x2501; ( FUNCTION LBRACKET Argument RBRACKET )
&#x2503;   &#x2523;&#x2501;&#x2501; FUNCTION &#x2501;&#x2501;&#x2501; ( 'ln' | 'cos' | 'exp' | 'sin' | 'acos' | 'asin' | 'sqrt' )
&#x2503;   &#x2523;&#x2501;&#x2501; LBRACKET &#x2501;&#x2501;&#x2501; '('
&#x2503;   &#x2523;&#x2501;&#x2501; Argument
&#x2503;   &#x2517;&#x2501;&#x2501; RBRACKET &#x2501;&#x2501;&#x2501; ')'
&#x2523;&#x2501;&#x2501; Value
&#x2503;   &#x2523;&#x2501;&#x2501; NUMBER
&#x2503;   &#x2503;   &#x2517;&#x2501;&#x2501; DIGIT+
&#x2503;   &#x2503;       &#x2517;&#x2501;&#x2501; DIGIT
&#x2503;   &#x2503;           &#x2517;&#x2501;&#x2501; ['0'-'9']
&#x2503;   &#x2517;&#x2501;&#x2501; VARIABLE
&#x2503;       &#x2517;&#x2501;&#x2501; ( UPPERCASE ( UPPERCASE | DIGIT | UNDERSCORE )* )
&#x2503;           &#x2523;&#x2501;&#x2501; UPPERCASE &#x2501;&#x2501;&#x2501; ['A'-'Z']
&#x2503;           &#x2517;&#x2501;&#x2501; ( UPPERCASE | DIGIT | UNDERSCORE )*
&#x2503;               &#x2517;&#x2501;&#x2501; ( UPPERCASE | DIGIT | UNDERSCORE )
&#x2503;                   &#x2523;&#x2501;&#x2501; UPPERCASE &#x2501;&#x2501;&#x2501; ['A'-'Z']
&#x2503;                   &#x2523;&#x2501;&#x2501; DIGIT
&#x2503;                   &#x2517;&#x2501;&#x2501; UNDERSCORE &#x2501;&#x2501;&#x2501; '_'
&#x2517;&#x2501;&#x2501; ( LBRACKET Expression RBRACKET )
    &#x2523;&#x2501;&#x2501; LBRACKET &#x2501;&#x2501;&#x2501; '('
    &#x2523;&#x2501;&#x2501; Expression
    &#x2503;   &#x2517;&#x2501;&#x2501; Sum
    &#x2503;       &#x2517;&#x2501;&#x2501; ( SignedTerm ( ADDITIVE Product )* )
    &#x2503;           &#x2523;&#x2501;&#x2501; SignedTerm
    &#x2503;           &#x2503;   &#x2523;&#x2501;&#x2501; ADDITIVE?
    &#x2503;           &#x2503;   &#x2503;   &#x2517;&#x2501;&#x2501; ADDITIVE &#x2501;&#x2501;&#x2501; ( '+' | '-' )
    &#x2503;           &#x2503;   &#x2517;&#x2501;&#x2501; Product
    &#x2503;           &#x2503;       &#x2523;&#x2501;&#x2501; Factor
    &#x2503;           &#x2503;       &#x2503;   &#x2523;&#x2501;&#x2501; Argument
    &#x2503;           &#x2503;       &#x2503;   &#x2517;&#x2501;&#x2501; ( RAISED SignedFactor )?
    &#x2503;           &#x2503;       &#x2503;       &#x2517;&#x2501;&#x2501; ( RAISED SignedFactor )
    &#x2503;           &#x2503;       &#x2503;           &#x2523;&#x2501;&#x2501; RAISED &#x2501;&#x2501;&#x2501; '^'
    &#x2503;           &#x2503;       &#x2503;           &#x2517;&#x2501;&#x2501; SignedFactor
    &#x2503;           &#x2503;       &#x2503;               &#x2517;&#x2501;&#x2501; ( ADDITIVE? Factor )
    &#x2503;           &#x2503;       &#x2503;                   &#x2523;&#x2501;&#x2501; ADDITIVE?
    &#x2503;           &#x2503;       &#x2503;                   &#x2503;   &#x2517;&#x2501;&#x2501; ADDITIVE &#x2501;&#x2501;&#x2501; ( '+' | '-' )
    &#x2503;           &#x2503;       &#x2503;                   &#x2517;&#x2501;&#x2501; Factor
    &#x2503;           &#x2503;       &#x2517;&#x2501;&#x2501; ( MULTIPLICATIVE SignedFactor )*
    &#x2503;           &#x2503;           &#x2517;&#x2501;&#x2501; ( MULTIPLICATIVE SignedFactor )
    &#x2503;           &#x2503;               &#x2523;&#x2501;&#x2501; MULTIPLICATIVE &#x2501;&#x2501;&#x2501; ( '&#xd7;' | '&#xf7;' )
    &#x2503;           &#x2503;               &#x2517;&#x2501;&#x2501; SignedFactor
    &#x2503;           &#x2517;&#x2501;&#x2501; ( ADDITIVE Product )*
    &#x2503;               &#x2517;&#x2501;&#x2501; ( ADDITIVE Product )
    &#x2503;                   &#x2523;&#x2501;&#x2501; ADDITIVE &#x2501;&#x2501;&#x2501; ( '+' | '-' )
    &#x2503;                   &#x2517;&#x2501;&#x2501; Product
    &#x2517;&#x2501;&#x2501; RBRACKET &#x2501;&#x2501;&#x2501; ')'
</pre></div></div>
</div>
</div>
<p><a name="issues"></a></p></div>
<div class="section">
<h3><a name="Common_issues"></a>Common issues</h3>
<div class="section">
<h4><a name="Unable_to_initialize_a_grammar_:"></a>Unable to initialize a grammar :</h4>

<div class="source">
<div class="source"><pre class="prettyprint linenums">java.lang.ExceptionInInitializerError
        at ...
        at ...
Caused by: java.lang.ClassCastException: ml.alternet.parser.Grammar$Proxy cannot be cast to org.example.grammar.Foo
    at org.example.grammar.Foo.&lt;clinit&gt;(Foo.java:9)
</pre></div></div>
<p>&#x27a1; Ensure to declare the grammar field <tt>Foo $ = $();</tt> <b>as the last field</b> in the grammar <tt>Foo</tt></p></div>
<div class="section">
<h4><a name="Fail_to_parse_with_NodeBuilder_:"></a>Fail to parse with <tt>NodeBuilder</tt> :</h4>

<div class="source">
<div class="source"><pre class="prettyprint linenums">FAILED: calcExpression_CanBe_evaluated
java.lang.IllegalArgumentException: No enum constant ml.alternet.parser.step4.ExpressionBuilder.CalcRules.Argument
    at java.lang.Enum.valueOf(Enum.java:238)
    at ml.alternet.parser.ast.NodeBuilder.lambda$14(NodeBuilder.java:154)
    at ml.alternet.parser.ast.NodeBuilder.ruleToNode(NodeBuilder.java:174)
    at ml.alternet.parser.handlers.TreeHandler.receive(TreeHandler.java:149)
</pre></div></div>
<p>&#x27a1; Ensure to declare a mapping for<tt>Argument</tt> in your node builder or to annotate it with <tt>@Fragment</tt> in the grammar.</p></div></div></div>
        </div>
    </div>
    <hr/>
    <footer>
      <div class="container">
        <div class="row">
            <p>Copyright &copy;2018
<a href="http://alternet.ml">Alternet</a>.
All rights reserved.</p>
        </div>
        <p id="poweredBy" class="pull-right">  <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
  </p>
        </div>
    </footer>
    </body>
</html>
